<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Введение в Redis: архитектура, режимы работы и основные команды | Персональный блог бэкенд-разработчика</title><meta name=keywords content><meta name=description content="Собрал материалы по работе с Redis. Уверен многим будет полезно. Текст объёмный, но вся информация важна.
Когда-то я бы был очень рад такому описанию. Оно поможет сделать старт, но может послужить и обычным справочником."><meta name=author content="akozadaev"><link rel=canonical href=https://akozadaev.github.io/myblog/posts/vvedenie_v_redis/><link crossorigin=anonymous href=/myblog/assets/css/stylesheet.a5781257de4197b8e3d54346acdf1dd55a9ba4cb91dcace192fc1baf228c08b5.css integrity="sha256-pXgSV95Bl7jj1UNGrN8d1VqbpMuR3KzhkvwbryKMCLU=" rel="preload stylesheet" as=style><link rel=icon href=https://akozadaev.github.io/myblog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://akozadaev.github.io/myblog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://akozadaev.github.io/myblog/favicon-32x32.png><link rel=apple-touch-icon href=https://akozadaev.github.io/myblog/apple-touch-icon.png><link rel=mask-icon href=https://akozadaev.github.io/myblog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://akozadaev.github.io/myblog/posts/vvedenie_v_redis/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://akozadaev.github.io/myblog/posts/vvedenie_v_redis/"><meta property="og:site_name" content="Персональный блог бэкенд-разработчика"><meta property="og:title" content="Введение в Redis: архитектура, режимы работы и основные команды"><meta property="og:description" content="Собрал материалы по работе с Redis. Уверен многим будет полезно. Текст объёмный, но вся информация важна. Когда-то я бы был очень рад такому описанию. Оно поможет сделать старт, но может послужить и обычным справочником."><meta property="og:locale" content="ru-ru"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-19T15:20:52+03:00"><meta property="article:modified_time" content="2025-12-19T15:20:52+03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Введение в Redis: архитектура, режимы работы и основные команды"><meta name=twitter:description content="Собрал материалы по работе с Redis. Уверен многим будет полезно. Текст объёмный, но вся информация важна.
Когда-то я бы был очень рад такому описанию. Оно поможет сделать старт, но может послужить и обычным справочником."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://akozadaev.github.io/myblog/posts/"},{"@type":"ListItem","position":2,"name":"Введение в Redis: архитектура, режимы работы и основные команды","item":"https://akozadaev.github.io/myblog/posts/vvedenie_v_redis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Введение в Redis: архитектура, режимы работы и основные команды","name":"Введение в Redis: архитектура, режимы работы и основные команды","description":"Собрал материалы по работе с Redis. Уверен многим будет полезно. Текст объёмный, но вся информация важна. Когда-то я бы был очень рад такому описанию. Оно поможет сделать старт, но может послужить и обычным справочником.\n","keywords":[],"articleBody":"Собрал материалы по работе с Redis. Уверен многим будет полезно. Текст объёмный, но вся информация важна. Когда-то я бы был очень рад такому описанию. Оно поможет сделать старт, но может послужить и обычным справочником.\nСодержание Введение в Redis Режимы работы Redis Redis Sentinel - отказоустойчивость для Standalone Архитектура Redis Cluster - детали Типы данных Redis и базовые команды Практические рекомендации Источники и дальнейшее изучение 1. Введение в Redis Что такое Redis? Redis (Remote Dictionary Server) — это открытая in-memory структура данных, которая может использоваться как база данных, кэш, брокер сообщений и хранилище очередей. Redis хранит данные в оперативной памяти, что обеспечивает исключительно высокую производительность операций чтения и записи.\nОсновные характеристики In-memory хранение: Данные хранятся в оперативной памяти, что обеспечивает скорость доступа в микросекундах Key-value store: Простая модель данных “ключ-значение” с поддержкой различных типов значений Персистентность: Опциональная возможность сохранения данных на диск (RDB snapshots, AOF) Высокая производительность: Сотни тысяч операций в секунду на одном ядре CPU Атомарные операции: Все команды выполняются атомарно, что обеспечивает консистентность данных Поддержка различных структур данных: Строки, списки, множества, хеши, отсортированные множества, потоки и др. Типичные сценарии использования Кэширование: Ускорение доступа к часто запрашиваемым данным Управление сессиями: Хранение сессий пользователей веб-приложений Очереди сообщений: Реализация pub/sub и очередей задач Рейт-лимитинг: Ограничение частоты запросов от клиентов Счетчики и аналитика: Реал-тайм метрики и статистика Геопространственные данные: Хранение и запросы по координатам Leaderboards: Рейтинги и таблицы лидеров 2. Режимы работы Redis Redis может работать в двух основных режимах: Standalone (однонодовый) и Cluster (кластерный). Выбор режима зависит от требований к масштабируемости, отказоустойчивости и объему данных.\n2.1. Standalone (однонодовый режим) Standalone — это режим работы с одним экземпляром Redis. Все данные хранятся на одном сервере, все операции выполняются на этом сервере.\nПлюсы Standalone режима ✅ Простота настройки и управления: Минимальная конфигурация, легко развернуть ✅ Низкая задержка: Нет накладных расходов на маршрутизацию между узлами ✅ Поддержка всех команд: Все команды Redis доступны без ограничений ✅ Простое резервное копирование: Один файл дампа для всей базы ✅ Поддержка множественных баз данных: Можно использовать SELECT для переключения между DB 0-15 Минусы Standalone режима ❌ Ограниченная масштабируемость: Ограничен объемом памяти одного сервера ❌ Единая точка отказа: При падении сервера теряется доступ ко всем данным ❌ Ограниченная производительность: Производительность ограничена одним CPU Когда использовать Standalone Разработка и тестирование Небольшие и средние проекты с объемом данных до нескольких десятков GB Приложения, где простота важнее масштабируемости Системы, где допустимы простои при обслуживании Пример конфигурации Standalone # redis.conf port 6379 bind 0.0.0.0 save 900 1 save 300 10 save 60 10000 2.2. Cluster (кластерный режим) Cluster — это режим работы Redis с несколькими узлами, где данные автоматически распределяются (шардируются) между узлами. Redis Cluster обеспечивает высокую доступность и горизонтальное масштабирование.\nПринцип шардирования (Sharding) Redis Cluster использует концепцию hash slots (хеш-слотов). Весь ключевой пространство разделено на 16384 слотов. Каждый узел кластера отвечает за определенный диапазон слотов.\nКлюч → CRC16(key) % 16384 → Hash Slot → Узел кластера Пример:\nКлюч user:123 → Hash Slot 5461 → Узел A (слоты 0-5460) Ключ product:456 → Hash Slot 10923 → Узел B (слоты 5461-10922) Ключ order:789 → Hash Slot 16383 → Узел C (слоты 10923-16383) Репликация и отказоустойчивость В Redis Cluster каждый мастер-узел может иметь один или несколько реплик (replica nodes). При падении мастер-узла одна из реплик автоматически становится мастером, обеспечивая непрерывность работы.\nМинимальная конфигурация кластера:\n3 мастер-узла (для обеспечения кворума) 3 реплики (по одной на каждый мастер) Итого: 6 узлов Ограничения Cluster режима Multi-key команды: Команды, работающие с несколькими ключами, требуют, чтобы все ключи находились на одном узле (в одном hash slot)\n❌ Не работают: MGET key1 key2 (если ключи на разных узлах) ✅ Работают: MGET {user}:1 {user}:2 (использование hash tags) Hash Tags: Для группировки ключей на одном узле используются hash tags\n{user}:123:profile → только {user} используется для вычисления слота {user}:123:settings → тот же слот, что и выше Базы данных: Поддерживается только DB 0 (SELECT не работает)\nНекоторые команды не поддерживаются:\nFLUSHDB, FLUSHALL — не работают в кластере KEYS * — работает только на локальных ключах узла SCAN — сканирует все узлы, но медленнее Когда использовать Cluster Большие объемы данных (сотни GB и более) Требования к высокой доступности (99.9%+ uptime) Необходимость горизонтального масштабирования Высокая нагрузка, требующая распределения по нескольким CPU Пример конфигурации Cluster # redis-cluster-node-1.conf port 7001 cluster-enabled yes cluster-config-file nodes-7001.conf cluster-node-timeout 5000 appendonly yes 2.3. Сравнительная таблица: Standalone vs Cluster Характеристика Standalone Cluster Масштабируемость Вертикальная (один сервер) Горизонтальная (множество узлов) Максимальный объем данных Ограничен RAM сервера Сумма RAM всех узлов Отказоустойчивость Нет (единая точка отказа) Да (автоматический failover) Производительность Высокая (один CPU) Очень высокая (множество CPU) Сложность настройки Низкая Высокая Поддержка всех команд Да Ограниченная (multi-key команды) Количество баз данных 0-15 Только 0 Использование Dev, тесты, малые проекты Production, большие проекты 3. Redis Sentinel - отказоустойчивость для Standalone Redis Sentinel — это система мониторинга и автоматического переключения при отказе (failover) для Redis в режиме Standalone. Sentinel обеспечивает высокую доступность без необходимости использования кластера.\nЧто такое Sentinel? Sentinel — это отдельный процесс (или набор процессов), который:\nМониторит состояние мастер-узлов и реплик Автоматически выполняет failover при падении мастера Уведомляет клиентов о смене мастера Предоставляет конфигурацию для автоматического обнаружения текущего мастера Архитектура Sentinel ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ Sentinel │ │ Sentinel │ │ Sentinel │ │ 1 │ │ 2 │ │ 3 │ └──────┬──────┘ └──────┬──────┘ └──────┬──────┘ │ │ │ └──────────────────┼──────────────────┘ │ ┌───────────┴───────────┐ │ │ ┌──────▼──────┐ ┌──────▼──────┐ │ Master │◄────────┤ Replica │ │ (Redis) │ │ (Redis) │ └─────────────┘ └─────────────┘ Минимальная конфигурация:\n3 Sentinel процесса (для кворума при принятии решений) 1 Master Redis 1 или более Replica Redis Конфигурация Sentinel Конфигурация Sentinel (sentinel.conf) # sentinel.conf port 26379 # Мониторинг мастера # sentinel monitor sentinel monitor mymaster 127.0.0.1 6379 2 # Пароль мастера (если используется) sentinel auth-pass mymaster mypassword # Время, после которого мастер считается недоступным (мс) sentinel down-after-milliseconds mymaster 5000 # Параллельные реплики для синхронизации при failover sentinel parallel-syncs mymaster 1 # Таймаут failover (мс) sentinel failover-timeout mymaster 10000 # Уведомления (опционально) sentinel notification-script mymaster /var/redis/notify.sh Параметры конфигурации:\nquorum — минимальное количество Sentinel, которые должны согласиться, что мастер недоступен down-after-milliseconds — время без ответа, после которого узел считается недоступным parallel-syncs — сколько реплик могут одновременно синхронизироваться с новым мастером failover-timeout — максимальное время для завершения failover Запуск Sentinel # Запуск Sentinel redis-sentinel sentinel.conf # Или через redis-server redis-server sentinel.conf --sentinel Команды Sentinel Проверка состояния # Подключение к Sentinel redis-cli -p 26379 # Получить информацию о мастерах SENTINEL masters # Получить информацию о конкретном мастере SENTINEL master mymaster # Получить реплики мастера SENTINEL replicas mymaster # Получить информацию о других Sentinel SENTINEL sentinels mymaster Ручной failover # Принудительный failover (только если мастер недоступен) SENTINEL failover mymaster # Сброс состояния Sentinel (после изменений конфигурации) SENTINEL reset mymaster Работа клиентов с Sentinel Go клиент import ( \"github.com/redis/go-redis/v9\" \"github.com/redis/go-redis/v9/sentinel\" ) // Настройка Sentinel rdb := redis.NewFailoverClient(\u0026redis.FailoverOptions{ MasterName: \"mymaster\", SentinelAddrs: []string{ \"127.0.0.1:26379\", \"127.0.0.1:26380\", \"127.0.0.1:26381\", }, Password: \"mypassword\", }) // Использование как обычного клиента val, err := rdb.Get(ctx, \"key\").Result() Автоматическое обнаружение мастера Клиент автоматически:\nПодключается к Sentinel Запрашивает адрес текущего мастера Подключается к мастеру Обновляет адрес при failover Преимущества и ограничения Sentinel Преимущества:\n✅ Высокая доступность для Standalone режима ✅ Автоматический failover ✅ Проще, чем Cluster (нет шардирования) ✅ Поддержка всех команд Redis ✅ Поддержка множественных баз данных (SELECT) Ограничения:\n❌ Нет горизонтального масштабирования (один мастер) ❌ Все данные на одном узле ❌ Производительность ограничена одним CPU ❌ Требует дополнительных процессов (Sentinel) Когда использовать Sentinel ✅ Нужна отказоустойчивость для Standalone ✅ Объем данных помещается на одном сервере ✅ Нужны все команды Redis без ограничений ✅ Простота важнее масштабируемости 4. Архитектура Redis Cluster - детали Node ID (Идентификатор узла) Каждый узел в Redis Cluster имеет уникальный Node ID — 160-битный случайный идентификатор, который генерируется при первом запуске узла.\nПросмотр Node ID # Подключение к узлу кластера redis-cli -c -p 7001 # Получить информацию о текущем узле CLUSTER MYID # Ответ: \"a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0\" # Получить информацию о всех узлах CLUSTER NODES Формат вывода CLUSTER NODES:\nПример:\na1b2c3... 127.0.0.1:7001@17001 myself,master - 0 0 0 connected 0-5460 b2c3d4... 127.0.0.1:7002@17002 master - 0 1699123456789 1 connected 5461-10922 c3d4e5... 127.0.0.1:7003@17003 master - 0 1699123456789 2 connected 10923-16383 d4e5f6... 127.0.0.1:7004@17004 slave a1b2c3... 0 1699123456789 0 connected e5f6g7... 127.0.0.1:7005@17005 slave b2c3d4... 0 1699123456789 0 connected f6g7h8... 127.0.0.1:7006@17006 slave c3d4e5... 0 1699123456789 0 connected Разбор формата:\nnode-id — уникальный идентификатор узла (160 бит) ip:port@cport — IP адрес, порт клиентов, порт кластера flags — роли узла (master, slave, myself, fail, …) master-node-id — ID мастера (для реплик), - для мастеров ping-sent, pong-recv — временные метки для heartbeat config-epoch — эпоха конфигурации (currentEpoch) link-state — состояние связи (connected, disconnected) slots — распределение слотов IP-адреса и порты В Redis Cluster каждый узел использует два порта:\nПорт клиентов (обычно 6379, 7000-7005) — для подключения клиентов Порт кластера (обычно +10000, например 16379, 17000-17005) — для коммуникации между узлами Конфигурация портов # redis-cluster-node-1.conf port 7001 # Порт для клиентов cluster-announce-ip 10.0.0.1 # Внешний IP (для Docker/K8s) cluster-announce-port 7001 # Внешний порт клиентов cluster-announce-bus-port 17001 # Внешний порт кластера Важно:\nВ Docker/Kubernetes нужно указывать внешние IP и порты Все узлы должны быть доступны друг другу по порту кластера Firewall должен разрешать соединения между узлами Роли узлов: Master и Replica Master (Мастер-узел) Мастер-узел — это узел, который:\nОбрабатывает запросы на чтение и запись Управляет определенным диапазоном hash slots Реплицирует данные на replica узлы Идентификация мастера:\nCLUSTER NODES | grep master # a1b2c3... 127.0.0.1:7001@17001 myself,master - 0 0 0 connected 0-5460 Replica (Реплика, ранее Slave) Replica-узел — это узел, который:\nКопирует данные с мастера (репликация) Обрабатывает только запросы на чтение (опционально) Автоматически становится мастером при failover Идентификация реплики:\nCLUSTER NODES | grep slave # d4e5f6... 127.0.0.1:7004@17004 slave a1b2c3... 0 0 0 connected Важно: Термин “slave” устарел, в новых версиях Redis используется “replica”, но в командах и выводе может встречаться “slave”.\nСвязи Master-Replica Настройка репликации # На реплике указываем мастера redis-cli -p 7004 CLUSTER REPLICATE a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0 Проверка репликации # На мастере - посмотреть реплики CLUSTER REPLICAS a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0 # На реплике - посмотреть мастера INFO replication # role:slave # master_host:127.0.0.1 # master_port:7001 # master_link_status:up # master_sync_in_progress:0 Типы репликации Синхронная репликация (по умолчанию):\nМастер ждет подтверждения от реплик перед ответом клиенту Гарантирует консистентность данных Может снижать производительность Асинхронная репликация:\nМастер не ждет подтверждения Выше производительность Возможна потеря данных при падении мастера Распределение слотов (Hash Slots) Redis Cluster использует 16384 hash slots для распределения данных.\nВычисление слота для ключа import \"hash/crc16\" func getSlot(key string) int { // Использование hash tags для группировки tagStart := strings.Index(key, \"{\") tagEnd := strings.Index(key, \"}\") var hashKey string if tagStart != -1 \u0026\u0026 tagEnd != -1 \u0026\u0026 tagEnd \u003e tagStart { // Используем только часть между { и } hashKey = key[tagStart+1 : tagEnd] } else { hashKey = key } // CRC16 и модуль 16384 return int(crc16.ChecksumCCITT([]byte(hashKey))) % 16384 } Просмотр распределения слотов # Посмотреть, какие слоты обслуживает узел CLUSTER SLOTS # Ответ: # 1) 1) (integer) 0 # Начало диапазона # 2) (integer) 5460 # Конец диапазона # 3) 1) \"127.0.0.1\" # IP мастера # 2) (integer) 7001 # Порт мастера # 3) \"a1b2c3...\" # Node ID мастера # 4) 1) \"127.0.0.1\" # IP реплики # 2) (integer) 7004 # Порт реплики # 3) \"d4e5f6...\" # Node ID реплики Перемещение слотов (Resharding) # Переместить слот 1000 с узла A на узел B redis-cli --cluster reshard 127.0.0.1:7001 # Интерактивный процесс: # 1. Сколько слотов переместить? (например, 1) # 2. Откуда? (node-id источника или \"all\") # 3. Куда? (node-id назначения) Shard ID Shard ID — это идентификатор шарда (части данных) в кластере. В Redis Cluster каждый мастер-узел представляет собой отдельный шард.\nВажно: В Redis Cluster нет явного понятия “shard-id” как отдельного параметра. Вместо этого используется:\nNode ID — для идентификации узла Hash Slots — для идентификации данных Однако, в некоторых контекстах (например, при мониторинге) шарды могут идентифицироваться по Node ID мастера.\nЭпохи конфигурации (Configuration Epochs) currentEpoch currentEpoch — это глобальный счетчик, который увеличивается при каждом изменении конфигурации кластера (failover, добавление/удаление узлов, перемещение слотов).\nНазначение:\nРазрешение конфликтов при одновременных изменениях конфигурации Определение актуальной версии конфигурации кластера Предотвращение split-brain ситуаций Просмотр currentEpoch:\nCLUSTER INFO # cluster_current_epoch:15 # Или для конкретного узла CLUSTER NODES # ... ... lastVoteEpoch lastVoteEpoch — это эпоха, за которую узел последний раз голосовал при выборе нового мастера во время failover.\nКак это работает:\nПри обнаружении недоступности мастера, реплики начинают выборы Каждая реплика запрашивает голоса у других мастеров Мастер голосует только один раз за каждую эпоху Реплика с большинством голосов становится новым мастером lastVoteEpoch обновляется, чтобы предотвратить повторное голосование Просмотр lastVoteEpoch:\n# Внутренняя информация (не доступна через стандартные команды) # Хранится в кластерном конфигурационном файле (nodes.conf) Пример процесса failover:\n1. Мастер A (currentEpoch=10) становится недоступным 2. Реплика B начинает выборы с currentEpoch=11 3. Мастер C голосует за B (lastVoteEpoch=11) 4. Мастер D голосует за B (lastVoteEpoch=11) 5. Реплика B становится мастером (currentEpoch=11) 6. Мастеры C и D обновляют конфигурацию (currentEpoch=11) Структура кластерного конфигурационного файла Каждый узел хранит конфигурацию в файле nodes-.conf:\na1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0 127.0.0.1:7001@17001 myself,master - 0 0 0 connected 0-5460 b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0 127.0.0.1:7002@17002 master - 0 1699123456789 1 connected 5461-10922 c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0 127.0.0.1:7003@17003 master - 0 1699123456789 2 connected 10923-16383 d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0 127.0.0.1:7004@17004 slave a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0 0 1699123456789 0 connected vars currentEpoch 15 lastVoteEpoch 12 Последняя строка содержит:\ncurrentEpoch — текущая эпоха конфигурации lastVoteEpoch — последняя эпоха, за которую узел голосовал Практические команды для работы с кластером Создание кластера # Создание кластера из 6 узлов (3 мастера + 3 реплики) redis-cli --cluster create \\ 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 \\ 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 \\ --cluster-replicas 1 Проверка состояния кластера # Информация о кластере CLUSTER INFO # Список всех узлов CLUSTER NODES # Проверка здоровья кластера redis-cli --cluster check 127.0.0.1:7001 Добавление нового узла # Добавить узел как реплику redis-cli --cluster add-node 127.0.0.1:7007 127.0.0.1:7001 \\ --cluster-slave \\ --cluster-master-id a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0 Удаление узла # Удалить узел (слоты должны быть перемещены заранее) redis-cli --cluster del-node 127.0.0.1:7001 d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0 5. Типы данных Redis и базовые команды Redis поддерживает множество типов данных, каждый из которых оптимизирован для определенных сценариев использования. Рассмотрим основные команды для работы с Redis.\n3.1. Строки (Strings) Строки — это самый простой тип данных в Redis. Значением может быть строка, число или бинарные данные до 512 MB.\nGET / SET / DEL Назначение: Базовые операции для работы с ключами и значениями.\nСинтаксис:\nSET key value [EX seconds] [PX milliseconds] [NX|XX] GET key DEL key [key ...] Примеры через CLI:\nredis-cli\u003e SET user:1:name \"Иван\" OK redis-cli\u003e GET user:1:name \"Иван\" redis-cli\u003e SET user:1:age 25 EX 3600 # TTL 1 час OK redis-cli\u003e DEL user:1:name (integer) 1 Пример на Go:\npackage main import ( \"context\" \"fmt\" \"github.com/redis/go-redis/v9\" ) func main() { ctx := context.Background() rdb := redis.NewClient(\u0026redis.Options{ Addr: \"localhost:6379\", }) // SET err := rdb.Set(ctx, \"user:1:name\", \"Иван\", 0).Err() if err != nil { panic(err) } // GET val, err := rdb.Get(ctx, \"user:1:name\").Result() if err != nil { panic(err) } fmt.Println(\"user:1:name\", val) // SET с TTL err = rdb.Set(ctx, \"user:1:age\", \"25\", time.Hour).Err() if err != nil { panic(err) } // DEL err = rdb.Del(ctx, \"user:1:name\").Err() if err != nil { panic(err) } } Особенности:\nSET — атомарная операция, O(1) GET — O(1) DEL — O(N), где N — количество ключей SET с флагом NX — устанавливает значение только если ключ не существует SET с флагом XX — устанавливает значение только если ключ существует 3.2. Множества (Sets) Множества — это неупорядоченные коллекции уникальных строк. Операции с множествами очень быстрые.\nSADD / SMEMBERS Назначение: Добавление элементов в множество и получение всех элементов.\nСинтаксис:\nSADD key member [member ...] SMEMBERS key Примеры через CLI:\nredis-cli\u003e SADD tags:user:1 \"golang\" \"redis\" \"docker\" (integer) 3 redis-cli\u003e SMEMBERS tags:user:1 1) \"docker\" 2) \"golang\" 3) \"redis\" redis-cli\u003e SADD tags:user:1 \"golang\" # Дубликат не добавится (integer) 0 Пример на Go:\n// SADD err := rdb.SAdd(ctx, \"tags:user:1\", \"golang\", \"redis\", \"docker\").Err() if err != nil { panic(err) } // SMEMBERS members, err := rdb.SMembers(ctx, \"tags:user:1\").Result() if err != nil { panic(err) } fmt.Println(\"Tags:\", members) // [docker golang redis] Особенности:\nSADD — O(N), где N — количество добавляемых элементов SMEMBERS — O(N), где N — количество элементов в множестве Автоматическое удаление дубликатов Поддержка операций пересечения, объединения, разности множеств 3.3. Метаданные ключей TYPE Назначение: Определение типа данных, хранящегося по ключу.\nСинтаксис:\nTYPE key Примеры через CLI:\nredis-cli\u003e SET key1 \"value\" OK redis-cli\u003e SADD key2 \"member\" (integer) 1 redis-cli\u003e TYPE key1 string redis-cli\u003e TYPE key2 set redis-cli\u003e TYPE nonexistent none Пример на Go:\nkeyType, err := rdb.Type(ctx, \"key1\").Result() if err != nil { panic(err) } fmt.Println(\"Type:\", keyType) // string, set, list, hash, zset, stream, none Возвращаемые типы:\nstring, list, set, zset, hash, stream, none EXPIRE / TTL Назначение: Установка времени жизни ключа и проверка оставшегося времени.\nСинтаксис:\nEXPIRE key seconds TTL key Примеры через CLI:\nredis-cli\u003e SET session:abc123 \"user_data\" OK redis-cli\u003e EXPIRE session:abc123 3600 (integer) 1 redis-cli\u003e TTL session:abc123 (integer) 3598 redis-cli\u003e TTL nonexistent (integer) -2 redis-cli\u003e TTL persistent_key (integer) -1 # Ключ существует, но TTL не установлен Пример на Go:\n// EXPIRE err := rdb.Expire(ctx, \"session:abc123\", time.Hour).Err() if err != nil { panic(err) } // TTL ttl, err := rdb.TTL(ctx, \"session:abc123\").Result() if err != nil { panic(err) } fmt.Println(\"TTL:\", ttl) // time.Duration или -1 (нет TTL), -2 (ключ не существует) Особенности:\nEXPIRE — O(1) TTL — O(1) Ключ автоматически удаляется по истечении TTL Можно установить TTL при создании ключа: SET key value EX 3600 3.4. Пайплайны и транзакции PIPELINE Назначение: Группировка нескольких команд для отправки на сервер одной партией. Команды выполняются последовательно, но без гарантии атомарности.\nОсобенности Pipeline:\nКоманды отправляются одной партией (меньше сетевых round-trips) Команды выполняются последовательно НЕ атомарно: Если одна команда упадет, остальные все равно выполнятся Результаты возвращаются в том же порядке, что и команды Пример на Go:\npipe := rdb.Pipeline() pipe.Set(ctx, \"key1\", \"value1\", 0) pipe.Set(ctx, \"key2\", \"value2\", 0) pipe.Get(ctx, \"key1\") cmds, err := pipe.Exec(ctx) if err != nil { panic(err) } // Обработка результатов for _, cmd := range cmds { fmt.Println(cmd.String()) } Когда использовать Pipeline:\nМножественные операции, которые не требуют атомарности Оптимизация производительности при большом количестве команд Операции с ключами, которые могут быть на разных узлах в кластере TXPIPELINE (MULTI/EXEC) Назначение: Транзакция — группа команд, выполняемых атомарно. Все команды выполняются или не выполняются вообще.\nОсобенности транзакций:\nАтомарность: Все команды выполняются как единое целое Изоляция: Команды выполняются последовательно, без прерываний В Redis Cluster: Все ключи в транзакции должны быть на одном узле (один hash slot) Пример на Go:\npipe := rdb.TxPipeline() pipe.Set(ctx, \"account:1:balance\", \"1000\", 0) pipe.Incr(ctx, \"account:1:balance\") pipe.Get(ctx, \"account:1:balance\") _, err := pipe.Exec(ctx) if err != nil { // Если любая команда упадет, вся транзакция откатывается panic(err) } Разница между Pipeline и TxPipeline:\nХарактеристика Pipeline TxPipeline Атомарность Нет Да Откат при ошибке Нет Да Производительность Выше Ниже (дополнительные проверки) Использование в кластере Может работать с ключами на разных узлах Все ключи должны быть на одном узле Когда использовать транзакции:\nОперации, требующие атомарности (например, перевод денег) Операции, где критична консистентность данных Когда все ключи гарантированно на одном узле (или используются hash tags) 3.5. Итерация по ключам SCAN Назначение: Инкрементальная итерация по ключам базы данных. Безопасная альтернатива команде KEYS *.\nПочему SCAN, а не KEYS?\nKEYS * блокирует сервер на время выполнения (может занять секунды или минуты) SCAN работает инкрементально, не блокируя сервер SCAN можно прервать в любой момент SCAN безопасен для использования в production Синтаксис:\nSCAN cursor [MATCH pattern] [COUNT count] Примеры через CLI:\nredis-cli\u003e SET user:1:name \"Иван\" OK redis-cli\u003e SET user:2:name \"Петр\" OK redis-cli\u003e SET product:1:name \"Товар\" OK redis-cli\u003e SCAN 0 MATCH user:* COUNT 10 1) \"3\" # Следующий cursor 2) 1) \"user:1:name\" 2) \"user:2:name\" redis-cli\u003e SCAN 3 MATCH user:* COUNT 10 1) \"0\" # 0 означает конец итерации 2) (empty list or set) Пример на Go:\nvar cursor uint64 var keys []string for { var batch []string batch, cursor, err = rdb.Scan(ctx, cursor, \"user:*\", 100).Result() if err != nil { panic(err) } keys = append(keys, batch...) if cursor == 0 { // Конец итерации break } } fmt.Println(\"Found keys:\", keys) Варианты SCAN:\nSCAN — итерация по всем ключам SSCAN — итерация по элементам множества HSCAN — итерация по полям хеша ZSCAN — итерация по элементам отсортированного множества Особенности:\nCOUNT — это подсказка, реальное количество может отличаться Один и тот же ключ может быть возвращен несколько раз (но это редко) В кластере SCAN сканирует все узлы, что может быть медленнее 3.6. Очистка базы данных FLUSHDB / FLUSHALL Назначение: Удаление всех ключей из текущей базы данных (FLUSHDB) или всех баз данных (FLUSHALL).\n⚠️ ВАЖНО: Эти команды ОПАСНЫ в production!\nСинтаксис:\nFLUSHDB [ASYNC] FLUSHALL [ASYNC] Примеры через CLI:\nredis-cli\u003e SET key1 \"value1\" OK redis-cli\u003e SET key2 \"value2\" OK redis-cli\u003e FLUSHDB OK redis-cli\u003e GET key1 (nil) # Ключ удален Ограничения:\n❌ Не работает в Redis Cluster: Эти команды отключены в кластерном режиме ⚠️ Удаляет ВСЕ данные: Невозможно откатить операцию ⚠️ Блокирует сервер: Может занять время на больших базах Безопасная альтернатива в кластере:\n// Использование SCAN + DEL для безопасной очистки func safeFlush(ctx context.Context, rdb *redis.Client) error { var cursor uint64 for { keys, nextCursor, err := rdb.Scan(ctx, cursor, \"*\", 1000).Result() if err != nil { return err } if len(keys) \u003e 0 { err = rdb.Del(ctx, keys...).Err() if err != nil { return err } } cursor = nextCursor if cursor == 0 { break } } return nil } Когда использовать:\n✅ Только в тестовой/разработческой среде ✅ При полном сбросе данных (с предварительным бэкапом) ❌ НИКОГДА в production без явной необходимости 3.7. Redis Streams Streams — это структура данных для работы с логами событий и сообщениями. Похожа на Kafka, но встроена в Redis.\nXADD / XREAD / XDEL Назначение:\nXADD — добавление сообщения в поток XREAD — чтение сообщений из потока XDEL — удаление сообщения из потока Синтаксис:\nXADD stream * field1 value1 [field2 value2 ...] XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...] XDEL stream id [id ...] Примеры через CLI:\n# Добавление сообщения redis-cli\u003e XADD events * user_id 123 action \"login\" timestamp 1234567890 \"1699123456789-0\" # Чтение всех сообщений с начала redis-cli\u003e XREAD STREAMS events 0 1) 1) \"events\" 2) 1) 1) \"1699123456789-0\" 2) 1) \"user_id\" 2) \"123\" 3) \"action\" 4) \"login\" 5) \"timestamp\" 6) \"1234567890\" # Чтение новых сообщений (блокирующее) redis-cli\u003e XREAD BLOCK 1000 STREAMS events $ (nil) # Нет новых сообщений, вернулось через 1 секунду # Удаление сообщения redis-cli\u003e XDEL events 1699123456789-0 (integer) 1 Пример на Go:\n// XADD - добавление события id, err := rdb.XAdd(ctx, \u0026redis.XAddArgs{ Stream: \"events\", Values: map[string]interface{}{ \"user_id\": 123, \"action\": \"login\", \"timestamp\": time.Now().Unix(), }, }).Result() if err != nil { panic(err) } fmt.Println(\"Event ID:\", id) // XREAD - чтение событий streams, err := rdb.XRead(ctx, \u0026redis.XReadArgs{ Streams: []string{\"events\", \"0\"}, // 0 = с начала Count: 10, Block: time.Second, }).Result() if err != nil { panic(err) } for _, stream := range streams { for _, message := range stream.Messages { fmt.Printf(\"ID: %s, Values: %v\\n\", message.ID, message.Values) } } // XDEL - удаление события err = rdb.XDel(ctx, \"events\", id).Err() if err != nil { panic(err) } Особенности Streams:\nСообщения упорядочены по времени (ID содержит timestamp) Поддержка consumer groups для распределенной обработки Автоматическое удаление старых сообщений (MAXLEN) В кластере stream должен быть на одном узле (используйте hash tags) Использование в кластере:\n// Важно: stream ключ должен быть обернут в hash tag streamKey := \"{events}:myStream\" // Все операции с этим stream на одном узле id, err := rdb.XAdd(ctx, \u0026redis.XAddArgs{ Stream: streamKey, // Используем обернутый ключ Values: map[string]interface{}{\"data\": \"value\"}, }).Result() Типичные сценарии использования:\nEvent sourcing (хранение истории событий) Очереди сообщений Логирование и аудит Real-time аналитика 3.8. Дополнительные полезные команды INCR / DECR Атомарное увеличение/уменьшение числового значения.\n// Счетчик просмотров views, err := rdb.Incr(ctx, \"page:123:views\").Result() // Атомарное увеличение на N views, err := rdb.IncrBy(ctx, \"page:123:views\", 5).Result() HSET / HGET / HGETALL Работа с хешами (hash maps).\n// Сохранение объекта пользователя err := rdb.HSet(ctx, \"user:1\", map[string]interface{}{ \"name\": \"Иван\", \"email\": \"ivan@example.com\", \"age\": 25, }).Err() // Получение всех полей user, err := rdb.HGetAll(ctx, \"user:1\").Result() // map[string]string{\"name\": \"Иван\", \"email\": \"ivan@example.com\", \"age\": \"25\"} LPUSH / RPUSH / LPOP / RPOP Работа со списками (очереди, стеки).\n// Добавление в очередь err := rdb.LPush(ctx, \"queue:tasks\", \"task1\", \"task2\").Err() // Извлечение из очереди task, err := rdb.RPop(ctx, \"queue:tasks\").Result() ZADD / ZRANGE Работа с отсортированными множествами (sorted sets).\n// Добавление в рейтинг err := rdb.ZAdd(ctx, \"leaderboard\", redis.Z{ Score: 1000, Member: \"player1\", }).Err() // Получение топ-10 topPlayers, err := rdb.ZRevRange(ctx, \"leaderboard\", 0, 9).Result() 6. Практические рекомендации 4.1. Безопасное использование Redis в production Аутентификация Всегда используйте пароль для защиты Redis:\n# redis.conf requirepass your_strong_password_here rdb := redis.NewClient(\u0026redis.Options{ Addr: \"localhost:6379\", Password: \"your_strong_password_here\", }) Защита от FLUSHDB Переименуйте опасные команды: # redis.conf rename-command FLUSHDB \"\" rename-command FLUSHALL \"\" rename-command CONFIG \"CONFIG_9a7b8c5d4e3f2g1h0i9j8k7l6m5n4o3p2q1r0\" Используйте отдельные инстансы для разных целей: Production данные Кэш Очереди Ограничение доступа # redis.conf # Разрешить подключения только с определенных IP bind 127.0.0.1 10.0.0.0/8 # Ограничить количество подключений maxclients 10000 4.2. Когда использовать кластер, а когда standalone Используйте Standalone, если:\n✅ Объем данных \u003c 50-100 GB ✅ Нет критических требований к uptime ✅ Простота важнее масштабируемости ✅ Разработка и тестирование Используйте Cluster, если:\n✅ Объем данных \u003e 100 GB ✅ Требуется 99.9%+ uptime ✅ Нужно горизонтальное масштабирование ✅ Высокая нагрузка (миллионы операций в секунду) 4.3. Ошибки новичков ❌ Использование KEYS * в production // ПЛОХО - блокирует сервер keys, err := rdb.Keys(ctx, \"*\").Result() // ХОРОШО - используйте SCAN var cursor uint64 for { batch, nextCursor, err := rdb.Scan(ctx, cursor, \"*\", 100).Result() // обработка batch cursor = nextCursor if cursor == 0 { break } } ❌ Игнорирование TTL // ПЛОХО - данные накапливаются rdb.Set(ctx, \"cache:key\", \"value\", 0) // ХОРОШО - устанавливайте TTL rdb.Set(ctx, \"cache:key\", \"value\", time.Hour) ❌ Использование транзакций с ключами на разных узлах // ПЛОХО - в кластере не сработает pipe := rdb.TxPipeline() pipe.Set(ctx, \"user:1\", \"value1\", 0) // Узел A pipe.Set(ctx, \"user:2\", \"value2\", 0) // Узел B pipe.Exec(ctx) // ОШИБКА: CROSSSLOT // ХОРОШО - используйте hash tags pipe := rdb.TxPipeline() pipe.Set(ctx, \"{user}:1\", \"value1\", 0) // Оба на одном узле pipe.Set(ctx, \"{user}:2\", \"value2\", 0) // благодаря hash tag pipe.Exec(ctx) // OK ❌ Неправильная обработка ошибок // ПЛОХО val, err := rdb.Get(ctx, \"key\").Result() fmt.Println(val) // Может быть пустая строка, если ключ не существует // ХОРОШО val, err := rdb.Get(ctx, \"key\").Result() if err == redis.Nil { // Ключ не существует return } else if err != nil { // Другая ошибка return err } // Ключ существует fmt.Println(val) 4.4. Оптимизация производительности Используйте Pipeline для множественных операций: pipe := rdb.Pipeline() for i := 0; i \u003c 1000; i++ { pipe.Set(ctx, fmt.Sprintf(\"key:%d\", i), \"value\", 0) } pipe.Exec(ctx) // Одна сетевая операция вместо 1000 Настройте connection pooling: rdb := redis.NewClient(\u0026redis.Options{ Addr: \"localhost:6379\", PoolSize: 20, // Количество соединений в пуле MinIdleConns: 10, // Минимальное количество idle соединений }) Используйте подходящие структуры данных: Строки для простых значений Хеши для объектов Списки для очередей Sets для уникальных коллекций Sorted Sets для рейтингов 7. Источники и дальнейшее изучение Официальная документация Redis Documentation: https://redis.io/documentation\nПолная документация по всем командам и возможностям Руководства по настройке и оптимизации Примеры использования Redis Commands Reference: https://redis.io/commands\nСправочник по всем командам Redis Описание параметров и возвращаемых значений Примеры использования Книги Redis in Action by Josiah L. Carlson\nПрактическое руководство по использованию Redis Реальные примеры и паттерны Оптимизация и best practices Redis: The Definitive Guide by Josiah L. Carlson, Carlos Baquero, and others\nПодробное описание архитектуры Redis Глубокое погружение в типы данных Администрирование и мониторинг Онлайн-ресурсы Redis University: https://university.redis.com/\nБесплатные курсы по Redis Видео-лекции и практические задания Сертификация Redis Playground: https://redis.io/docs/ui/play/\nИнтерактивная песочница для экспериментов Примеры команд и сценариев Без необходимости установки Redis локально GitHub и сообщество Redis GitHub: https://github.com/redis/redis\nИсходный код Redis Issue tracker и обсуждения Документация разработчика Redis Community: https://redis.io/community\nФорум сообщества Discord канал Meetups и конференции Дополнительные материалы Redis Labs Blog: https://redis.com/blog/\nСтатьи о best practices Кейсы использования Новости и обновления Redis YouTube Channel: https://www.youtube.com/c/RedisLabs\nВидео-туториалы Вебинары и презентации Демонстрации возможностей Заключение Redis — это мощный инструмент для работы с данными в памяти, который может значительно ускорить ваше приложение при правильном использовании. Понимание различий между режимами работы, знание основных команд и следование best practices помогут вам эффективно использовать Redis в ваших проектах.\nПомните:\nВыбирайте режим работы в зависимости от ваших требований Используйте подходящие структуры данных для ваших задач Всегда устанавливайте TTL для временных данных Избегайте блокирующих команд в production Используйте hash tags в кластере для группировки связанных данных Удачи в изучении Redis! 🚀\nДокумент подготовлен на основе официальной документации Redis 7.x и практического опыта разработки.\n","wordCount":"4609","inLanguage":"en","datePublished":"2025-12-19T15:20:52+03:00","dateModified":"2025-12-19T15:20:52+03:00","author":{"@type":"Person","name":"akozadaev"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://akozadaev.github.io/myblog/posts/vvedenie_v_redis/"},"publisher":{"@type":"Organization","name":"Персональный блог бэкенд-разработчика","logo":{"@type":"ImageObject","url":"https://akozadaev.github.io/myblog/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://akozadaev.github.io/myblog/ accesskey=h title="Персональный блог бэкенд-разработчика (Alt + H)">Персональный блог бэкенд-разработчика</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Введение в Redis: архитектура, режимы работы и основные команды</h1><div class=post-meta><span title='2025-12-19 15:20:52 +0300 MSK'>December 19, 2025</span>&nbsp;·&nbsp;<span>akozadaev</span></div></header><div class=post-content><p>Собрал материалы по работе с Redis. Уверен многим будет полезно. Текст объёмный, но вся информация важна.
Когда-то я бы был очень рад такому описанию. Оно поможет сделать старт, но может послужить и обычным справочником.</p><hr><h2 id=содержание>Содержание<a hidden class=anchor aria-hidden=true href=#содержание>#</a></h2><ol><li><a href=#1-%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-redis>Введение в Redis</a></li><li><a href=#2-%D1%80%D0%B5%D0%B6%D0%B8%D0%BC%D1%8B-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-redis>Режимы работы Redis</a></li><li><a href=#3-redis-sentinel---%D0%BE%D1%82%D0%BA%D0%B0%D0%B7%D0%BE%D1%83%D1%81%D1%82%D0%BE%D0%B9%D1%87%D0%B8%D0%B2%D0%BE%D1%81%D1%82%D1%8C-%D0%B4%D0%BB%D1%8F-standalone>Redis Sentinel - отказоустойчивость для Standalone</a></li><li><a href=#4-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0-redis-cluster---%D0%B4%D0%B5%D1%82%D0%B0%D0%BB%D0%B8>Архитектура Redis Cluster - детали</a></li><li><a href=#5-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-redis-%D0%B8-%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B>Типы данных Redis и базовые команды</a></li><li><a href=#6-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D1%80%D0%B5%D0%BA%D0%BE%D0%BC%D0%B5%D0%BD%D0%B4%D0%B0%D1%86%D0%B8%D0%B8>Практические рекомендации</a></li><li><a href=#7-%D0%B8%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8-%D0%B8-%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D0%B5%D0%B9%D1%88%D0%B5%D0%B5-%D0%B8%D0%B7%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5>Источники и дальнейшее изучение</a></li></ol><hr><h2 id=1-введение-в-redis>1. Введение в Redis<a hidden class=anchor aria-hidden=true href=#1-введение-в-redis>#</a></h2><h3 id=что-такое-redis>Что такое Redis?<a hidden class=anchor aria-hidden=true href=#что-такое-redis>#</a></h3><p><strong>Redis</strong> (Remote Dictionary Server) — это открытая in-memory структура данных, которая может использоваться как база данных, кэш, брокер сообщений и хранилище очередей. Redis хранит данные в оперативной памяти, что обеспечивает исключительно высокую производительность операций чтения и записи.</p><h3 id=основные-характеристики>Основные характеристики<a hidden class=anchor aria-hidden=true href=#основные-характеристики>#</a></h3><ul><li><strong>In-memory хранение</strong>: Данные хранятся в оперативной памяти, что обеспечивает скорость доступа в микросекундах</li><li><strong>Key-value store</strong>: Простая модель данных &ldquo;ключ-значение&rdquo; с поддержкой различных типов значений</li><li><strong>Персистентность</strong>: Опциональная возможность сохранения данных на диск (RDB snapshots, AOF)</li><li><strong>Высокая производительность</strong>: Сотни тысяч операций в секунду на одном ядре CPU</li><li><strong>Атомарные операции</strong>: Все команды выполняются атомарно, что обеспечивает консистентность данных</li><li><strong>Поддержка различных структур данных</strong>: Строки, списки, множества, хеши, отсортированные множества, потоки и др.</li></ul><h3 id=типичные-сценарии-использования>Типичные сценарии использования<a hidden class=anchor aria-hidden=true href=#типичные-сценарии-использования>#</a></h3><ol><li><strong>Кэширование</strong>: Ускорение доступа к часто запрашиваемым данным</li><li><strong>Управление сессиями</strong>: Хранение сессий пользователей веб-приложений</li><li><strong>Очереди сообщений</strong>: Реализация pub/sub и очередей задач</li><li><strong>Рейт-лимитинг</strong>: Ограничение частоты запросов от клиентов</li><li><strong>Счетчики и аналитика</strong>: Реал-тайм метрики и статистика</li><li><strong>Геопространственные данные</strong>: Хранение и запросы по координатам</li><li><strong>Leaderboards</strong>: Рейтинги и таблицы лидеров</li></ol><hr><h2 id=2-режимы-работы-redis>2. Режимы работы Redis<a hidden class=anchor aria-hidden=true href=#2-режимы-работы-redis>#</a></h2><p>Redis может работать в двух основных режимах: <strong>Standalone</strong> (однонодовый) и <strong>Cluster</strong> (кластерный). Выбор режима зависит от требований к масштабируемости, отказоустойчивости и объему данных.</p><h3 id=21-standalone-однонодовый-режим>2.1. Standalone (однонодовый режим)<a hidden class=anchor aria-hidden=true href=#21-standalone-однонодовый-режим>#</a></h3><p><strong>Standalone</strong> — это режим работы с одним экземпляром Redis. Все данные хранятся на одном сервере, все операции выполняются на этом сервере.</p><h4 id=плюсы-standalone-режима>Плюсы Standalone режима<a hidden class=anchor aria-hidden=true href=#плюсы-standalone-режима>#</a></h4><ul><li>✅ <strong>Простота настройки и управления</strong>: Минимальная конфигурация, легко развернуть</li><li>✅ <strong>Низкая задержка</strong>: Нет накладных расходов на маршрутизацию между узлами</li><li>✅ <strong>Поддержка всех команд</strong>: Все команды Redis доступны без ограничений</li><li>✅ <strong>Простое резервное копирование</strong>: Один файл дампа для всей базы</li><li>✅ <strong>Поддержка множественных баз данных</strong>: Можно использовать SELECT для переключения между DB 0-15</li></ul><h4 id=минусы-standalone-режима>Минусы Standalone режима<a hidden class=anchor aria-hidden=true href=#минусы-standalone-режима>#</a></h4><ul><li>❌ <strong>Ограниченная масштабируемость</strong>: Ограничен объемом памяти одного сервера</li><li>❌ <strong>Единая точка отказа</strong>: При падении сервера теряется доступ ко всем данным</li><li>❌ <strong>Ограниченная производительность</strong>: Производительность ограничена одним CPU</li></ul><h4 id=когда-использовать-standalone>Когда использовать Standalone<a hidden class=anchor aria-hidden=true href=#когда-использовать-standalone>#</a></h4><ul><li>Разработка и тестирование</li><li>Небольшие и средние проекты с объемом данных до нескольких десятков GB</li><li>Приложения, где простота важнее масштабируемости</li><li>Системы, где допустимы простои при обслуживании</li></ul><h4 id=пример-конфигурации-standalone>Пример конфигурации Standalone<a hidden class=anchor aria-hidden=true href=#пример-конфигурации-standalone>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># redis.conf</span>
</span></span><span class=line><span class=cl>port <span class=m>6379</span>
</span></span><span class=line><span class=cl><span class=nb>bind</span> 0.0.0.0
</span></span><span class=line><span class=cl>save <span class=m>900</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>save <span class=m>300</span> <span class=m>10</span>
</span></span><span class=line><span class=cl>save <span class=m>60</span> <span class=m>10000</span>
</span></span></code></pre></div><h3 id=22-cluster-кластерный-режим>2.2. Cluster (кластерный режим)<a hidden class=anchor aria-hidden=true href=#22-cluster-кластерный-режим>#</a></h3><p><strong>Cluster</strong> — это режим работы Redis с несколькими узлами, где данные автоматически распределяются (шардируются) между узлами. Redis Cluster обеспечивает высокую доступность и горизонтальное масштабирование.</p><h4 id=принцип-шардирования-sharding>Принцип шардирования (Sharding)<a hidden class=anchor aria-hidden=true href=#принцип-шардирования-sharding>#</a></h4><p>Redis Cluster использует концепцию <strong>hash slots</strong> (хеш-слотов). Весь ключевой пространство разделено на 16384 слотов. Каждый узел кластера отвечает за определенный диапазон слотов.</p><pre tabindex=0><code>Ключ → CRC16(key) % 16384 → Hash Slot → Узел кластера
</code></pre><p><strong>Пример:</strong></p><ul><li>Ключ <code>user:123</code> → Hash Slot 5461 → Узел A (слоты 0-5460)</li><li>Ключ <code>product:456</code> → Hash Slot 10923 → Узел B (слоты 5461-10922)</li><li>Ключ <code>order:789</code> → Hash Slot 16383 → Узел C (слоты 10923-16383)</li></ul><h4 id=репликация-и-отказоустойчивость>Репликация и отказоустойчивость<a hidden class=anchor aria-hidden=true href=#репликация-и-отказоустойчивость>#</a></h4><p>В Redis Cluster каждый мастер-узел может иметь один или несколько реплик (replica nodes). При падении мастер-узла одна из реплик автоматически становится мастером, обеспечивая непрерывность работы.</p><p><strong>Минимальная конфигурация кластера:</strong></p><ul><li>3 мастер-узла (для обеспечения кворума)</li><li>3 реплики (по одной на каждый мастер)</li><li>Итого: 6 узлов</li></ul><h4 id=ограничения-cluster-режима>Ограничения Cluster режима<a hidden class=anchor aria-hidden=true href=#ограничения-cluster-режима>#</a></h4><ol><li><p><strong>Multi-key команды</strong>: Команды, работающие с несколькими ключами, требуют, чтобы все ключи находились на одном узле (в одном hash slot)</p><ul><li>❌ Не работают: <code>MGET key1 key2</code> (если ключи на разных узлах)</li><li>✅ Работают: <code>MGET {user}:1 {user}:2</code> (использование hash tags)</li></ul></li><li><p><strong>Hash Tags</strong>: Для группировки ключей на одном узле используются hash tags</p><pre tabindex=0><code class=language-redis data-lang=redis>{user}:123:profile  → только {user} используется для вычисления слота
{user}:123:settings → тот же слот, что и выше
</code></pre></li><li><p><strong>Базы данных</strong>: Поддерживается только DB 0 (SELECT не работает)</p></li><li><p><strong>Некоторые команды не поддерживаются</strong>:</p><ul><li><code>FLUSHDB</code>, <code>FLUSHALL</code> — не работают в кластере</li><li><code>KEYS *</code> — работает только на локальных ключах узла</li><li><code>SCAN</code> — сканирует все узлы, но медленнее</li></ul></li></ol><h4 id=когда-использовать-cluster>Когда использовать Cluster<a hidden class=anchor aria-hidden=true href=#когда-использовать-cluster>#</a></h4><ul><li>Большие объемы данных (сотни GB и более)</li><li>Требования к высокой доступности (99.9%+ uptime)</li><li>Необходимость горизонтального масштабирования</li><li>Высокая нагрузка, требующая распределения по нескольким CPU</li></ul><h4 id=пример-конфигурации-cluster>Пример конфигурации Cluster<a hidden class=anchor aria-hidden=true href=#пример-конфигурации-cluster>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># redis-cluster-node-1.conf</span>
</span></span><span class=line><span class=cl>port <span class=m>7001</span>
</span></span><span class=line><span class=cl>cluster-enabled yes
</span></span><span class=line><span class=cl>cluster-config-file nodes-7001.conf
</span></span><span class=line><span class=cl>cluster-node-timeout <span class=m>5000</span>
</span></span><span class=line><span class=cl>appendonly yes
</span></span></code></pre></div><h3 id=23-сравнительная-таблица-standalone-vs-cluster>2.3. Сравнительная таблица: Standalone vs Cluster<a hidden class=anchor aria-hidden=true href=#23-сравнительная-таблица-standalone-vs-cluster>#</a></h3><table><thead><tr><th>Характеристика</th><th>Standalone</th><th>Cluster</th></tr></thead><tbody><tr><td><strong>Масштабируемость</strong></td><td>Вертикальная (один сервер)</td><td>Горизонтальная (множество узлов)</td></tr><tr><td><strong>Максимальный объем данных</strong></td><td>Ограничен RAM сервера</td><td>Сумма RAM всех узлов</td></tr><tr><td><strong>Отказоустойчивость</strong></td><td>Нет (единая точка отказа)</td><td>Да (автоматический failover)</td></tr><tr><td><strong>Производительность</strong></td><td>Высокая (один CPU)</td><td>Очень высокая (множество CPU)</td></tr><tr><td><strong>Сложность настройки</strong></td><td>Низкая</td><td>Высокая</td></tr><tr><td><strong>Поддержка всех команд</strong></td><td>Да</td><td>Ограниченная (multi-key команды)</td></tr><tr><td><strong>Количество баз данных</strong></td><td>0-15</td><td>Только 0</td></tr><tr><td><strong>Использование</strong></td><td>Dev, тесты, малые проекты</td><td>Production, большие проекты</td></tr></tbody></table><hr><h2 id=3-redis-sentinel---отказоустойчивость-для-standalone>3. Redis Sentinel - отказоустойчивость для Standalone<a hidden class=anchor aria-hidden=true href=#3-redis-sentinel---отказоустойчивость-для-standalone>#</a></h2><p><strong>Redis Sentinel</strong> — это система мониторинга и автоматического переключения при отказе (failover) для Redis в режиме Standalone. Sentinel обеспечивает высокую доступность без необходимости использования кластера.</p><h3 id=что-такое-sentinel>Что такое Sentinel?<a hidden class=anchor aria-hidden=true href=#что-такое-sentinel>#</a></h3><p>Sentinel — это отдельный процесс (или набор процессов), который:</p><ul><li>Мониторит состояние мастер-узлов и реплик</li><li>Автоматически выполняет failover при падении мастера</li><li>Уведомляет клиентов о смене мастера</li><li>Предоставляет конфигурацию для автоматического обнаружения текущего мастера</li></ul><h3 id=архитектура-sentinel>Архитектура Sentinel<a hidden class=anchor aria-hidden=true href=#архитектура-sentinel>#</a></h3><pre tabindex=0><code>┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  Sentinel  │     │  Sentinel   │     │  Sentinel   │
│     1      │     │      2      │     │      3      │
└──────┬──────┘     └──────┬──────┘     └──────┬──────┘
       │                  │                  │
       └──────────────────┼──────────────────┘
                          │
              ┌───────────┴───────────┐
              │                       │
       ┌──────▼──────┐         ┌──────▼──────┐
       │   Master    │◄────────┤   Replica   │
       │  (Redis)    │         │  (Redis)    │
       └─────────────┘         └─────────────┘
</code></pre><p><strong>Минимальная конфигурация:</strong></p><ul><li>3 Sentinel процесса (для кворума при принятии решений)</li><li>1 Master Redis</li><li>1 или более Replica Redis</li></ul><h3 id=конфигурация-sentinel>Конфигурация Sentinel<a hidden class=anchor aria-hidden=true href=#конфигурация-sentinel>#</a></h3><h4 id=конфигурация-sentinel-sentinelconf>Конфигурация Sentinel (sentinel.conf)<a hidden class=anchor aria-hidden=true href=#конфигурация-sentinel-sentinelconf>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># sentinel.conf</span>
</span></span><span class=line><span class=cl>port <span class=m>26379</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Мониторинг мастера</span>
</span></span><span class=line><span class=cl><span class=c1># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span>
</span></span><span class=line><span class=cl>sentinel monitor mymaster 127.0.0.1 <span class=m>6379</span> <span class=m>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Пароль мастера (если используется)</span>
</span></span><span class=line><span class=cl>sentinel auth-pass mymaster mypassword
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Время, после которого мастер считается недоступным (мс)</span>
</span></span><span class=line><span class=cl>sentinel down-after-milliseconds mymaster <span class=m>5000</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Параллельные реплики для синхронизации при failover</span>
</span></span><span class=line><span class=cl>sentinel parallel-syncs mymaster <span class=m>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Таймаут failover (мс)</span>
</span></span><span class=line><span class=cl>sentinel failover-timeout mymaster <span class=m>10000</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Уведомления (опционально)</span>
</span></span><span class=line><span class=cl>sentinel notification-script mymaster /var/redis/notify.sh
</span></span></code></pre></div><p><strong>Параметры конфигурации:</strong></p><ul><li><code>quorum</code> — минимальное количество Sentinel, которые должны согласиться, что мастер недоступен</li><li><code>down-after-milliseconds</code> — время без ответа, после которого узел считается недоступным</li><li><code>parallel-syncs</code> — сколько реплик могут одновременно синхронизироваться с новым мастером</li><li><code>failover-timeout</code> — максимальное время для завершения failover</li></ul><h3 id=запуск-sentinel>Запуск Sentinel<a hidden class=anchor aria-hidden=true href=#запуск-sentinel>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Запуск Sentinel</span>
</span></span><span class=line><span class=cl>redis-sentinel sentinel.conf
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Или через redis-server</span>
</span></span><span class=line><span class=cl>redis-server sentinel.conf --sentinel
</span></span></code></pre></div><h3 id=команды-sentinel>Команды Sentinel<a hidden class=anchor aria-hidden=true href=#команды-sentinel>#</a></h3><h4 id=проверка-состояния>Проверка состояния<a hidden class=anchor aria-hidden=true href=#проверка-состояния>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Подключение к Sentinel</span>
</span></span><span class=line><span class=cl>redis-cli -p <span class=m>26379</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Получить информацию о мастерах</span>
</span></span><span class=line><span class=cl>SENTINEL masters
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Получить информацию о конкретном мастере</span>
</span></span><span class=line><span class=cl>SENTINEL master mymaster
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Получить реплики мастера</span>
</span></span><span class=line><span class=cl>SENTINEL replicas mymaster
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Получить информацию о других Sentinel</span>
</span></span><span class=line><span class=cl>SENTINEL sentinels mymaster
</span></span></code></pre></div><h4 id=ручной-failover>Ручной failover<a hidden class=anchor aria-hidden=true href=#ручной-failover>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Принудительный failover (только если мастер недоступен)</span>
</span></span><span class=line><span class=cl>SENTINEL failover mymaster
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Сброс состояния Sentinel (после изменений конфигурации)</span>
</span></span><span class=line><span class=cl>SENTINEL reset mymaster
</span></span></code></pre></div><h3 id=работа-клиентов-с-sentinel>Работа клиентов с Sentinel<a hidden class=anchor aria-hidden=true href=#работа-клиентов-с-sentinel>#</a></h3><h4 id=go-клиент>Go клиент<a hidden class=anchor aria-hidden=true href=#go-клиент>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/redis/go-redis/v9&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/redis/go-redis/v9/sentinel&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Настройка Sentinel</span>
</span></span><span class=line><span class=cl><span class=nx>rdb</span> <span class=o>:=</span> <span class=nx>redis</span><span class=p>.</span><span class=nf>NewFailoverClient</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>redis</span><span class=p>.</span><span class=nx>FailoverOptions</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>MasterName</span><span class=p>:</span>    <span class=s>&#34;mymaster&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>SentinelAddrs</span><span class=p>:</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;127.0.0.1:26379&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;127.0.0.1:26380&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;127.0.0.1:26381&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nx>Password</span><span class=p>:</span> <span class=s>&#34;mypassword&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Использование как обычного клиента</span>
</span></span><span class=line><span class=cl><span class=nx>val</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;key&#34;</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span></code></pre></div><h4 id=автоматическое-обнаружение-мастера>Автоматическое обнаружение мастера<a hidden class=anchor aria-hidden=true href=#автоматическое-обнаружение-мастера>#</a></h4><p>Клиент автоматически:</p><ol><li>Подключается к Sentinel</li><li>Запрашивает адрес текущего мастера</li><li>Подключается к мастеру</li><li>Обновляет адрес при failover</li></ol><h3 id=преимущества-и-ограничения-sentinel>Преимущества и ограничения Sentinel<a hidden class=anchor aria-hidden=true href=#преимущества-и-ограничения-sentinel>#</a></h3><p><strong>Преимущества:</strong></p><ul><li>✅ Высокая доступность для Standalone режима</li><li>✅ Автоматический failover</li><li>✅ Проще, чем Cluster (нет шардирования)</li><li>✅ Поддержка всех команд Redis</li><li>✅ Поддержка множественных баз данных (SELECT)</li></ul><p><strong>Ограничения:</strong></p><ul><li>❌ Нет горизонтального масштабирования (один мастер)</li><li>❌ Все данные на одном узле</li><li>❌ Производительность ограничена одним CPU</li><li>❌ Требует дополнительных процессов (Sentinel)</li></ul><h3 id=когда-использовать-sentinel>Когда использовать Sentinel<a hidden class=anchor aria-hidden=true href=#когда-использовать-sentinel>#</a></h3><ul><li>✅ Нужна отказоустойчивость для Standalone</li><li>✅ Объем данных помещается на одном сервере</li><li>✅ Нужны все команды Redis без ограничений</li><li>✅ Простота важнее масштабируемости</li></ul><hr><h2 id=4-архитектура-redis-cluster---детали>4. Архитектура Redis Cluster - детали<a hidden class=anchor aria-hidden=true href=#4-архитектура-redis-cluster---детали>#</a></h2><h3 id=node-id-идентификатор-узла>Node ID (Идентификатор узла)<a hidden class=anchor aria-hidden=true href=#node-id-идентификатор-узла>#</a></h3><p>Каждый узел в Redis Cluster имеет уникальный <strong>Node ID</strong> — 160-битный случайный идентификатор, который генерируется при первом запуске узла.</p><h4 id=просмотр-node-id>Просмотр Node ID<a hidden class=anchor aria-hidden=true href=#просмотр-node-id>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Подключение к узлу кластера</span>
</span></span><span class=line><span class=cl>redis-cli -c -p <span class=m>7001</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Получить информацию о текущем узле</span>
</span></span><span class=line><span class=cl>CLUSTER MYID
</span></span><span class=line><span class=cl><span class=c1># Ответ: &#34;a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Получить информацию о всех узлах</span>
</span></span><span class=line><span class=cl>CLUSTER NODES
</span></span></code></pre></div><p><strong>Формат вывода CLUSTER NODES:</strong></p><pre tabindex=0><code>&lt;node-id&gt; &lt;ip:port@cport&gt; &lt;flags&gt; &lt;master-node-id&gt; &lt;ping-sent&gt; &lt;pong-recv&gt; &lt;config-epoch&gt; &lt;link-state&gt; &lt;slots&gt;
</code></pre><p><strong>Пример:</strong></p><pre tabindex=0><code>a1b2c3... 127.0.0.1:7001@17001 myself,master - 0 0 0 connected 0-5460
b2c3d4... 127.0.0.1:7002@17002 master - 0 1699123456789 1 connected 5461-10922
c3d4e5... 127.0.0.1:7003@17003 master - 0 1699123456789 2 connected 10923-16383
d4e5f6... 127.0.0.1:7004@17004 slave a1b2c3... 0 1699123456789 0 connected
e5f6g7... 127.0.0.1:7005@17005 slave b2c3d4... 0 1699123456789 0 connected
f6g7h8... 127.0.0.1:7006@17006 slave c3d4e5... 0 1699123456789 0 connected
</code></pre><p><strong>Разбор формата:</strong></p><ul><li><code>node-id</code> — уникальный идентификатор узла (160 бит)</li><li><code>ip:port@cport</code> — IP адрес, порт клиентов, порт кластера</li><li><code>flags</code> — роли узла (master, slave, myself, fail, &mldr;)</li><li><code>master-node-id</code> — ID мастера (для реплик), <code>-</code> для мастеров</li><li><code>ping-sent</code>, <code>pong-recv</code> — временные метки для heartbeat</li><li><code>config-epoch</code> — эпоха конфигурации (currentEpoch)</li><li><code>link-state</code> — состояние связи (connected, disconnected)</li><li><code>slots</code> — распределение слотов</li></ul><h3 id=ip-адреса-и-порты>IP-адреса и порты<a hidden class=anchor aria-hidden=true href=#ip-адреса-и-порты>#</a></h3><p>В Redis Cluster каждый узел использует два порта:</p><ol><li><strong>Порт клиентов</strong> (обычно 6379, 7000-7005) — для подключения клиентов</li><li><strong>Порт кластера</strong> (обычно +10000, например 16379, 17000-17005) — для коммуникации между узлами</li></ol><h4 id=конфигурация-портов>Конфигурация портов<a hidden class=anchor aria-hidden=true href=#конфигурация-портов>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># redis-cluster-node-1.conf</span>
</span></span><span class=line><span class=cl>port <span class=m>7001</span>                    <span class=c1># Порт для клиентов</span>
</span></span><span class=line><span class=cl>cluster-announce-ip 10.0.0.1  <span class=c1># Внешний IP (для Docker/K8s)</span>
</span></span><span class=line><span class=cl>cluster-announce-port <span class=m>7001</span>   <span class=c1># Внешний порт клиентов</span>
</span></span><span class=line><span class=cl>cluster-announce-bus-port <span class=m>17001</span>  <span class=c1># Внешний порт кластера</span>
</span></span></code></pre></div><p><strong>Важно:</strong></p><ul><li>В Docker/Kubernetes нужно указывать внешние IP и порты</li><li>Все узлы должны быть доступны друг другу по порту кластера</li><li>Firewall должен разрешать соединения между узлами</li></ul><h3 id=роли-узлов-master-и-replica>Роли узлов: Master и Replica<a hidden class=anchor aria-hidden=true href=#роли-узлов-master-и-replica>#</a></h3><h4 id=master-мастер-узел>Master (Мастер-узел)<a hidden class=anchor aria-hidden=true href=#master-мастер-узел>#</a></h4><p><strong>Мастер-узел</strong> — это узел, который:</p><ul><li>Обрабатывает запросы на чтение и запись</li><li>Управляет определенным диапазоном hash slots</li><li>Реплицирует данные на replica узлы</li></ul><p><strong>Идентификация мастера:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>CLUSTER NODES <span class=p>|</span> grep master
</span></span><span class=line><span class=cl><span class=c1># a1b2c3... 127.0.0.1:7001@17001 myself,master - 0 0 0 connected 0-5460</span>
</span></span></code></pre></div><h4 id=replica-реплика-ранее-slave>Replica (Реплика, ранее Slave)<a hidden class=anchor aria-hidden=true href=#replica-реплика-ранее-slave>#</a></h4><p><strong>Replica-узел</strong> — это узел, который:</p><ul><li>Копирует данные с мастера (репликация)</li><li>Обрабатывает только запросы на чтение (опционально)</li><li>Автоматически становится мастером при failover</li></ul><p><strong>Идентификация реплики:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>CLUSTER NODES <span class=p>|</span> grep slave
</span></span><span class=line><span class=cl><span class=c1># d4e5f6... 127.0.0.1:7004@17004 slave a1b2c3... 0 0 0 connected</span>
</span></span></code></pre></div><p><strong>Важно:</strong> Термин &ldquo;slave&rdquo; устарел, в новых версиях Redis используется &ldquo;replica&rdquo;, но в командах и выводе может встречаться &ldquo;slave&rdquo;.</p><h3 id=связи-master-replica>Связи Master-Replica<a hidden class=anchor aria-hidden=true href=#связи-master-replica>#</a></h3><h4 id=настройка-репликации>Настройка репликации<a hidden class=anchor aria-hidden=true href=#настройка-репликации>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># На реплике указываем мастера</span>
</span></span><span class=line><span class=cl>redis-cli -p <span class=m>7004</span>
</span></span><span class=line><span class=cl>CLUSTER REPLICATE a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0
</span></span></code></pre></div><h4 id=проверка-репликации>Проверка репликации<a hidden class=anchor aria-hidden=true href=#проверка-репликации>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># На мастере - посмотреть реплики</span>
</span></span><span class=line><span class=cl>CLUSTER REPLICAS a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># На реплике - посмотреть мастера</span>
</span></span><span class=line><span class=cl>INFO replication
</span></span><span class=line><span class=cl><span class=c1># role:slave</span>
</span></span><span class=line><span class=cl><span class=c1># master_host:127.0.0.1</span>
</span></span><span class=line><span class=cl><span class=c1># master_port:7001</span>
</span></span><span class=line><span class=cl><span class=c1># master_link_status:up</span>
</span></span><span class=line><span class=cl><span class=c1># master_sync_in_progress:0</span>
</span></span></code></pre></div><h4 id=типы-репликации>Типы репликации<a hidden class=anchor aria-hidden=true href=#типы-репликации>#</a></h4><ol><li><p><strong>Синхронная репликация</strong> (по умолчанию):</p><ul><li>Мастер ждет подтверждения от реплик перед ответом клиенту</li><li>Гарантирует консистентность данных</li><li>Может снижать производительность</li></ul></li><li><p><strong>Асинхронная репликация</strong>:</p><ul><li>Мастер не ждет подтверждения</li><li>Выше производительность</li><li>Возможна потеря данных при падении мастера</li></ul></li></ol><h3 id=распределение-слотов-hash-slots>Распределение слотов (Hash Slots)<a hidden class=anchor aria-hidden=true href=#распределение-слотов-hash-slots>#</a></h3><p>Redis Cluster использует <strong>16384 hash slots</strong> для распределения данных.</p><h4 id=вычисление-слота-для-ключа>Вычисление слота для ключа<a hidden class=anchor aria-hidden=true href=#вычисление-слота-для-ключа>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;hash/crc16&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getSlot</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Использование hash tags для группировки</span>
</span></span><span class=line><span class=cl>    <span class=nx>tagStart</span> <span class=o>:=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>Index</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=s>&#34;{&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>tagEnd</span> <span class=o>:=</span> <span class=nx>strings</span><span class=p>.</span><span class=nf>Index</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=s>&#34;}&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>hashKey</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>tagStart</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=nx>tagEnd</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=nx>tagEnd</span> <span class=p>&gt;</span> <span class=nx>tagStart</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Используем только часть между { и }</span>
</span></span><span class=line><span class=cl>        <span class=nx>hashKey</span> <span class=p>=</span> <span class=nx>key</span><span class=p>[</span><span class=nx>tagStart</span><span class=o>+</span><span class=mi>1</span> <span class=p>:</span> <span class=nx>tagEnd</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>hashKey</span> <span class=p>=</span> <span class=nx>key</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// CRC16 и модуль 16384</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>int</span><span class=p>(</span><span class=nx>crc16</span><span class=p>.</span><span class=nf>ChecksumCCITT</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>hashKey</span><span class=p>)))</span> <span class=o>%</span> <span class=mi>16384</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=просмотр-распределения-слотов>Просмотр распределения слотов<a hidden class=anchor aria-hidden=true href=#просмотр-распределения-слотов>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Посмотреть, какие слоты обслуживает узел</span>
</span></span><span class=line><span class=cl>CLUSTER SLOTS
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Ответ:</span>
</span></span><span class=line><span class=cl><span class=c1># 1) 1) (integer) 0           # Начало диапазона</span>
</span></span><span class=line><span class=cl><span class=c1>#    2) (integer) 5460       # Конец диапазона</span>
</span></span><span class=line><span class=cl><span class=c1>#    3) 1) &#34;127.0.0.1&#34;       # IP мастера</span>
</span></span><span class=line><span class=cl><span class=c1>#       2) (integer) 7001    # Порт мастера</span>
</span></span><span class=line><span class=cl><span class=c1>#       3) &#34;a1b2c3...&#34;       # Node ID мастера</span>
</span></span><span class=line><span class=cl><span class=c1>#    4) 1) &#34;127.0.0.1&#34;       # IP реплики</span>
</span></span><span class=line><span class=cl><span class=c1>#       2) (integer) 7004    # Порт реплики</span>
</span></span><span class=line><span class=cl><span class=c1>#       3) &#34;d4e5f6...&#34;       # Node ID реплики</span>
</span></span></code></pre></div><h4 id=перемещение-слотов-resharding>Перемещение слотов (Resharding)<a hidden class=anchor aria-hidden=true href=#перемещение-слотов-resharding>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Переместить слот 1000 с узла A на узел B</span>
</span></span><span class=line><span class=cl>redis-cli --cluster reshard 127.0.0.1:7001
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Интерактивный процесс:</span>
</span></span><span class=line><span class=cl><span class=c1># 1. Сколько слотов переместить? (например, 1)</span>
</span></span><span class=line><span class=cl><span class=c1># 2. Откуда? (node-id источника или &#34;all&#34;)</span>
</span></span><span class=line><span class=cl><span class=c1># 3. Куда? (node-id назначения)</span>
</span></span></code></pre></div><h3 id=shard-id>Shard ID<a hidden class=anchor aria-hidden=true href=#shard-id>#</a></h3><p><strong>Shard ID</strong> — это идентификатор шарда (части данных) в кластере. В Redis Cluster каждый мастер-узел представляет собой отдельный шард.</p><p><strong>Важно:</strong> В Redis Cluster нет явного понятия &ldquo;shard-id&rdquo; как отдельного параметра. Вместо этого используется:</p><ul><li><strong>Node ID</strong> — для идентификации узла</li><li><strong>Hash Slots</strong> — для идентификации данных</li></ul><p>Однако, в некоторых контекстах (например, при мониторинге) шарды могут идентифицироваться по Node ID мастера.</p><h3 id=эпохи-конфигурации-configuration-epochs>Эпохи конфигурации (Configuration Epochs)<a hidden class=anchor aria-hidden=true href=#эпохи-конфигурации-configuration-epochs>#</a></h3><h4 id=currentepoch>currentEpoch<a hidden class=anchor aria-hidden=true href=#currentepoch>#</a></h4><p><strong>currentEpoch</strong> — это глобальный счетчик, который увеличивается при каждом изменении конфигурации кластера (failover, добавление/удаление узлов, перемещение слотов).</p><p><strong>Назначение:</strong></p><ul><li>Разрешение конфликтов при одновременных изменениях конфигурации</li><li>Определение актуальной версии конфигурации кластера</li><li>Предотвращение split-brain ситуаций</li></ul><p><strong>Просмотр currentEpoch:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>CLUSTER INFO
</span></span><span class=line><span class=cl><span class=c1># cluster_current_epoch:15</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Или для конкретного узла</span>
</span></span><span class=line><span class=cl>CLUSTER NODES
</span></span><span class=line><span class=cl><span class=c1># ... &lt;config-epoch&gt; ...</span>
</span></span></code></pre></div><h4 id=lastvoteepoch>lastVoteEpoch<a hidden class=anchor aria-hidden=true href=#lastvoteepoch>#</a></h4><p><strong>lastVoteEpoch</strong> — это эпоха, за которую узел последний раз голосовал при выборе нового мастера во время failover.</p><p><strong>Как это работает:</strong></p><ol><li>При обнаружении недоступности мастера, реплики начинают выборы</li><li>Каждая реплика запрашивает голоса у других мастеров</li><li>Мастер голосует только один раз за каждую эпоху</li><li>Реплика с большинством голосов становится новым мастером</li><li><code>lastVoteEpoch</code> обновляется, чтобы предотвратить повторное голосование</li></ol><p><strong>Просмотр lastVoteEpoch:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Внутренняя информация (не доступна через стандартные команды)</span>
</span></span><span class=line><span class=cl><span class=c1># Хранится в кластерном конфигурационном файле (nodes.conf)</span>
</span></span></code></pre></div><p><strong>Пример процесса failover:</strong></p><pre tabindex=0><code>1. Мастер A (currentEpoch=10) становится недоступным
2. Реплика B начинает выборы с currentEpoch=11
3. Мастер C голосует за B (lastVoteEpoch=11)
4. Мастер D голосует за B (lastVoteEpoch=11)
5. Реплика B становится мастером (currentEpoch=11)
6. Мастеры C и D обновляют конфигурацию (currentEpoch=11)
</code></pre><h3 id=структура-кластерного-конфигурационного-файла>Структура кластерного конфигурационного файла<a hidden class=anchor aria-hidden=true href=#структура-кластерного-конфигурационного-файла>#</a></h3><p>Каждый узел хранит конфигурацию в файле <code>nodes-&lt;port>.conf</code>:</p><pre tabindex=0><code>a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0 127.0.0.1:7001@17001 myself,master - 0 0 0 connected 0-5460
b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0 127.0.0.1:7002@17002 master - 0 1699123456789 1 connected 5461-10922
c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0 127.0.0.1:7003@17003 master - 0 1699123456789 2 connected 10923-16383
d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0 127.0.0.1:7004@17004 slave a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0 0 1699123456789 0 connected
vars currentEpoch 15 lastVoteEpoch 12
</code></pre><p><strong>Последняя строка содержит:</strong></p><ul><li><code>currentEpoch</code> — текущая эпоха конфигурации</li><li><code>lastVoteEpoch</code> — последняя эпоха, за которую узел голосовал</li></ul><h3 id=практические-команды-для-работы-с-кластером>Практические команды для работы с кластером<a hidden class=anchor aria-hidden=true href=#практические-команды-для-работы-с-кластером>#</a></h3><h4 id=создание-кластера>Создание кластера<a hidden class=anchor aria-hidden=true href=#создание-кластера>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Создание кластера из 6 узлов (3 мастера + 3 реплики)</span>
</span></span><span class=line><span class=cl>redis-cli --cluster create <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --cluster-replicas <span class=m>1</span>
</span></span></code></pre></div><h4 id=проверка-состояния-кластера>Проверка состояния кластера<a hidden class=anchor aria-hidden=true href=#проверка-состояния-кластера>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Информация о кластере</span>
</span></span><span class=line><span class=cl>CLUSTER INFO
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Список всех узлов</span>
</span></span><span class=line><span class=cl>CLUSTER NODES
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Проверка здоровья кластера</span>
</span></span><span class=line><span class=cl>redis-cli --cluster check 127.0.0.1:7001
</span></span></code></pre></div><h4 id=добавление-нового-узла>Добавление нового узла<a hidden class=anchor aria-hidden=true href=#добавление-нового-узла>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Добавить узел как реплику</span>
</span></span><span class=line><span class=cl>redis-cli --cluster add-node 127.0.0.1:7007 127.0.0.1:7001 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --cluster-slave <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --cluster-master-id a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0
</span></span></code></pre></div><h4 id=удаление-узла>Удаление узла<a hidden class=anchor aria-hidden=true href=#удаление-узла>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Удалить узел (слоты должны быть перемещены заранее)</span>
</span></span><span class=line><span class=cl>redis-cli --cluster del-node 127.0.0.1:7001 d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0
</span></span></code></pre></div><hr><h2 id=5-типы-данных-redis-и-базовые-команды>5. Типы данных Redis и базовые команды<a hidden class=anchor aria-hidden=true href=#5-типы-данных-redis-и-базовые-команды>#</a></h2><p>Redis поддерживает множество типов данных, каждый из которых оптимизирован для определенных сценариев использования. Рассмотрим основные команды для работы с Redis.</p><h3 id=31-строки-strings>3.1. Строки (Strings)<a hidden class=anchor aria-hidden=true href=#31-строки-strings>#</a></h3><p>Строки — это самый простой тип данных в Redis. Значением может быть строка, число или бинарные данные до 512 MB.</p><h4 id=get--set--del>GET / SET / DEL<a hidden class=anchor aria-hidden=true href=#get--set--del>#</a></h4><p><strong>Назначение</strong>: Базовые операции для работы с ключами и значениями.</p><p><strong>Синтаксис:</strong></p><pre tabindex=0><code class=language-redis data-lang=redis>SET key value [EX seconds] [PX milliseconds] [NX|XX]
GET key
DEL key [key ...]
</code></pre><p><strong>Примеры через CLI:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>redis-cli&gt; SET user:1:name <span class=s2>&#34;Иван&#34;</span>
</span></span><span class=line><span class=cl>OK
</span></span><span class=line><span class=cl>redis-cli&gt; GET user:1:name
</span></span><span class=line><span class=cl><span class=s2>&#34;Иван&#34;</span>
</span></span><span class=line><span class=cl>redis-cli&gt; SET user:1:age <span class=m>25</span> EX <span class=m>3600</span>  <span class=c1># TTL 1 час</span>
</span></span><span class=line><span class=cl>OK
</span></span><span class=line><span class=cl>redis-cli&gt; DEL user:1:name
</span></span><span class=line><span class=cl><span class=o>(</span>integer<span class=o>)</span> <span class=m>1</span>
</span></span></code></pre></div><p><strong>Пример на Go:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;context&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/redis/go-redis/v9&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ctx</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>rdb</span> <span class=o>:=</span> <span class=nx>redis</span><span class=p>.</span><span class=nf>NewClient</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>redis</span><span class=p>.</span><span class=nx>Options</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Addr</span><span class=p>:</span> <span class=s>&#34;localhost:6379&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// SET</span>
</span></span><span class=line><span class=cl>    <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;user:1:name&#34;</span><span class=p>,</span> <span class=s>&#34;Иван&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>).</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// GET</span>
</span></span><span class=line><span class=cl>    <span class=nx>val</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;user:1:name&#34;</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;user:1:name&#34;</span><span class=p>,</span> <span class=nx>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// SET с TTL</span>
</span></span><span class=line><span class=cl>    <span class=nx>err</span> <span class=p>=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;user:1:age&#34;</span><span class=p>,</span> <span class=s>&#34;25&#34;</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Hour</span><span class=p>).</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// DEL</span>
</span></span><span class=line><span class=cl>    <span class=nx>err</span> <span class=p>=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Del</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;user:1:name&#34;</span><span class=p>).</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Особенности:</strong></p><ul><li><code>SET</code> — атомарная операция, O(1)</li><li><code>GET</code> — O(1)</li><li><code>DEL</code> — O(N), где N — количество ключей</li><li><code>SET</code> с флагом <code>NX</code> — устанавливает значение только если ключ не существует</li><li><code>SET</code> с флагом <code>XX</code> — устанавливает значение только если ключ существует</li></ul><h3 id=32-множества-sets>3.2. Множества (Sets)<a hidden class=anchor aria-hidden=true href=#32-множества-sets>#</a></h3><p>Множества — это неупорядоченные коллекции уникальных строк. Операции с множествами очень быстрые.</p><h4 id=sadd--smembers>SADD / SMEMBERS<a hidden class=anchor aria-hidden=true href=#sadd--smembers>#</a></h4><p><strong>Назначение</strong>: Добавление элементов в множество и получение всех элементов.</p><p><strong>Синтаксис:</strong></p><pre tabindex=0><code class=language-redis data-lang=redis>SADD key member [member ...]
SMEMBERS key
</code></pre><p><strong>Примеры через CLI:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>redis-cli&gt; SADD tags:user:1 <span class=s2>&#34;golang&#34;</span> <span class=s2>&#34;redis&#34;</span> <span class=s2>&#34;docker&#34;</span>
</span></span><span class=line><span class=cl><span class=o>(</span>integer<span class=o>)</span> <span class=m>3</span>
</span></span><span class=line><span class=cl>redis-cli&gt; SMEMBERS tags:user:1
</span></span><span class=line><span class=cl>1<span class=o>)</span> <span class=s2>&#34;docker&#34;</span>
</span></span><span class=line><span class=cl>2<span class=o>)</span> <span class=s2>&#34;golang&#34;</span>
</span></span><span class=line><span class=cl>3<span class=o>)</span> <span class=s2>&#34;redis&#34;</span>
</span></span><span class=line><span class=cl>redis-cli&gt; SADD tags:user:1 <span class=s2>&#34;golang&#34;</span>  <span class=c1># Дубликат не добавится</span>
</span></span><span class=line><span class=cl><span class=o>(</span>integer<span class=o>)</span> <span class=m>0</span>
</span></span></code></pre></div><p><strong>Пример на Go:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// SADD</span>
</span></span><span class=line><span class=cl><span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>SAdd</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;tags:user:1&#34;</span><span class=p>,</span> <span class=s>&#34;golang&#34;</span><span class=p>,</span> <span class=s>&#34;redis&#34;</span><span class=p>,</span> <span class=s>&#34;docker&#34;</span><span class=p>).</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// SMEMBERS</span>
</span></span><span class=line><span class=cl><span class=nx>members</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>SMembers</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;tags:user:1&#34;</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Tags:&#34;</span><span class=p>,</span> <span class=nx>members</span><span class=p>)</span>  <span class=c1>// [docker golang redis]</span>
</span></span></code></pre></div><p><strong>Особенности:</strong></p><ul><li><code>SADD</code> — O(N), где N — количество добавляемых элементов</li><li><code>SMEMBERS</code> — O(N), где N — количество элементов в множестве</li><li>Автоматическое удаление дубликатов</li><li>Поддержка операций пересечения, объединения, разности множеств</li></ul><h3 id=33-метаданные-ключей>3.3. Метаданные ключей<a hidden class=anchor aria-hidden=true href=#33-метаданные-ключей>#</a></h3><h4 id=type>TYPE<a hidden class=anchor aria-hidden=true href=#type>#</a></h4><p><strong>Назначение</strong>: Определение типа данных, хранящегося по ключу.</p><p><strong>Синтаксис:</strong></p><pre tabindex=0><code class=language-redis data-lang=redis>TYPE key
</code></pre><p><strong>Примеры через CLI:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>redis-cli&gt; SET key1 <span class=s2>&#34;value&#34;</span>
</span></span><span class=line><span class=cl>OK
</span></span><span class=line><span class=cl>redis-cli&gt; SADD key2 <span class=s2>&#34;member&#34;</span>
</span></span><span class=line><span class=cl><span class=o>(</span>integer<span class=o>)</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>redis-cli&gt; TYPE key1
</span></span><span class=line><span class=cl>string
</span></span><span class=line><span class=cl>redis-cli&gt; TYPE key2
</span></span><span class=line><span class=cl><span class=nb>set</span>
</span></span><span class=line><span class=cl>redis-cli&gt; TYPE nonexistent
</span></span><span class=line><span class=cl>none
</span></span></code></pre></div><p><strong>Пример на Go:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>keyType</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Type</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;key1&#34;</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Type:&#34;</span><span class=p>,</span> <span class=nx>keyType</span><span class=p>)</span>  <span class=c1>// string, set, list, hash, zset, stream, none</span>
</span></span></code></pre></div><p><strong>Возвращаемые типы:</strong></p><ul><li><code>string</code>, <code>list</code>, <code>set</code>, <code>zset</code>, <code>hash</code>, <code>stream</code>, <code>none</code></li></ul><h4 id=expire--ttl>EXPIRE / TTL<a hidden class=anchor aria-hidden=true href=#expire--ttl>#</a></h4><p><strong>Назначение</strong>: Установка времени жизни ключа и проверка оставшегося времени.</p><p><strong>Синтаксис:</strong></p><pre tabindex=0><code class=language-redis data-lang=redis>EXPIRE key seconds
TTL key
</code></pre><p><strong>Примеры через CLI:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>redis-cli&gt; SET session:abc123 <span class=s2>&#34;user_data&#34;</span>
</span></span><span class=line><span class=cl>OK
</span></span><span class=line><span class=cl>redis-cli&gt; EXPIRE session:abc123 <span class=m>3600</span>
</span></span><span class=line><span class=cl><span class=o>(</span>integer<span class=o>)</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>redis-cli&gt; TTL session:abc123
</span></span><span class=line><span class=cl><span class=o>(</span>integer<span class=o>)</span> <span class=m>3598</span>
</span></span><span class=line><span class=cl>redis-cli&gt; TTL nonexistent
</span></span><span class=line><span class=cl><span class=o>(</span>integer<span class=o>)</span> -2
</span></span><span class=line><span class=cl>redis-cli&gt; TTL persistent_key
</span></span><span class=line><span class=cl><span class=o>(</span>integer<span class=o>)</span> -1  <span class=c1># Ключ существует, но TTL не установлен</span>
</span></span></code></pre></div><p><strong>Пример на Go:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// EXPIRE</span>
</span></span><span class=line><span class=cl><span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Expire</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;session:abc123&#34;</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Hour</span><span class=p>).</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// TTL</span>
</span></span><span class=line><span class=cl><span class=nx>ttl</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>TTL</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;session:abc123&#34;</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;TTL:&#34;</span><span class=p>,</span> <span class=nx>ttl</span><span class=p>)</span>  <span class=c1>// time.Duration или -1 (нет TTL), -2 (ключ не существует)</span>
</span></span></code></pre></div><p><strong>Особенности:</strong></p><ul><li><code>EXPIRE</code> — O(1)</li><li><code>TTL</code> — O(1)</li><li>Ключ автоматически удаляется по истечении TTL</li><li>Можно установить TTL при создании ключа: <code>SET key value EX 3600</code></li></ul><h3 id=34-пайплайны-и-транзакции>3.4. Пайплайны и транзакции<a hidden class=anchor aria-hidden=true href=#34-пайплайны-и-транзакции>#</a></h3><h4 id=pipeline>PIPELINE<a hidden class=anchor aria-hidden=true href=#pipeline>#</a></h4><p><strong>Назначение</strong>: Группировка нескольких команд для отправки на сервер одной партией. Команды выполняются последовательно, но без гарантии атомарности.</p><p><strong>Особенности Pipeline:</strong></p><ul><li>Команды отправляются одной партией (меньше сетевых round-trips)</li><li>Команды выполняются последовательно</li><li><strong>НЕ атомарно</strong>: Если одна команда упадет, остальные все равно выполнятся</li><li>Результаты возвращаются в том же порядке, что и команды</li></ul><p><strong>Пример на Go:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>pipe</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Pipeline</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>pipe</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;key1&#34;</span><span class=p>,</span> <span class=s>&#34;value1&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>pipe</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;key2&#34;</span><span class=p>,</span> <span class=s>&#34;value2&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>pipe</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;key1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>cmds</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>pipe</span><span class=p>.</span><span class=nf>Exec</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Обработка результатов</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>cmd</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>cmds</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>cmd</span><span class=p>.</span><span class=nf>String</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Когда использовать Pipeline:</strong></p><ul><li>Множественные операции, которые не требуют атомарности</li><li>Оптимизация производительности при большом количестве команд</li><li>Операции с ключами, которые могут быть на разных узлах в кластере</li></ul><h4 id=txpipeline-multiexec>TXPIPELINE (MULTI/EXEC)<a hidden class=anchor aria-hidden=true href=#txpipeline-multiexec>#</a></h4><p><strong>Назначение</strong>: Транзакция — группа команд, выполняемых атомарно. Все команды выполняются или не выполняются вообще.</p><p><strong>Особенности транзакций:</strong></p><ul><li><strong>Атомарность</strong>: Все команды выполняются как единое целое</li><li><strong>Изоляция</strong>: Команды выполняются последовательно, без прерываний</li><li><strong>В Redis Cluster</strong>: Все ключи в транзакции должны быть на одном узле (один hash slot)</li></ul><p><strong>Пример на Go:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>pipe</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>TxPipeline</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>pipe</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;account:1:balance&#34;</span><span class=p>,</span> <span class=s>&#34;1000&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>pipe</span><span class=p>.</span><span class=nf>Incr</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;account:1:balance&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>pipe</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;account:1:balance&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>pipe</span><span class=p>.</span><span class=nf>Exec</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Если любая команда упадет, вся транзакция откатывается</span>
</span></span><span class=line><span class=cl>    <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Разница между Pipeline и TxPipeline:</strong></p><table><thead><tr><th>Характеристика</th><th>Pipeline</th><th>TxPipeline</th></tr></thead><tbody><tr><td><strong>Атомарность</strong></td><td>Нет</td><td>Да</td></tr><tr><td><strong>Откат при ошибке</strong></td><td>Нет</td><td>Да</td></tr><tr><td><strong>Производительность</strong></td><td>Выше</td><td>Ниже (дополнительные проверки)</td></tr><tr><td><strong>Использование в кластере</strong></td><td>Может работать с ключами на разных узлах</td><td>Все ключи должны быть на одном узле</td></tr></tbody></table><p><strong>Когда использовать транзакции:</strong></p><ul><li>Операции, требующие атомарности (например, перевод денег)</li><li>Операции, где критична консистентность данных</li><li>Когда все ключи гарантированно на одном узле (или используются hash tags)</li></ul><h3 id=35-итерация-по-ключам>3.5. Итерация по ключам<a hidden class=anchor aria-hidden=true href=#35-итерация-по-ключам>#</a></h3><h4 id=scan>SCAN<a hidden class=anchor aria-hidden=true href=#scan>#</a></h4><p><strong>Назначение</strong>: Инкрементальная итерация по ключам базы данных. Безопасная альтернатива команде <code>KEYS *</code>.</p><p><strong>Почему SCAN, а не KEYS?</strong></p><ul><li><code>KEYS *</code> блокирует сервер на время выполнения (может занять секунды или минуты)</li><li><code>SCAN</code> работает инкрементально, не блокируя сервер</li><li><code>SCAN</code> можно прервать в любой момент</li><li><code>SCAN</code> безопасен для использования в production</li></ul><p><strong>Синтаксис:</strong></p><pre tabindex=0><code class=language-redis data-lang=redis>SCAN cursor [MATCH pattern] [COUNT count]
</code></pre><p><strong>Примеры через CLI:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>redis-cli&gt; SET user:1:name <span class=s2>&#34;Иван&#34;</span>
</span></span><span class=line><span class=cl>OK
</span></span><span class=line><span class=cl>redis-cli&gt; SET user:2:name <span class=s2>&#34;Петр&#34;</span>
</span></span><span class=line><span class=cl>OK
</span></span><span class=line><span class=cl>redis-cli&gt; SET product:1:name <span class=s2>&#34;Товар&#34;</span>
</span></span><span class=line><span class=cl>OK
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>redis-cli&gt; SCAN <span class=m>0</span> MATCH user:* COUNT <span class=m>10</span>
</span></span><span class=line><span class=cl>1<span class=o>)</span> <span class=s2>&#34;3&#34;</span>           <span class=c1># Следующий cursor</span>
</span></span><span class=line><span class=cl>2<span class=o>)</span> 1<span class=o>)</span> <span class=s2>&#34;user:1:name&#34;</span>
</span></span><span class=line><span class=cl>   2<span class=o>)</span> <span class=s2>&#34;user:2:name&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>redis-cli&gt; SCAN <span class=m>3</span> MATCH user:* COUNT <span class=m>10</span>
</span></span><span class=line><span class=cl>1<span class=o>)</span> <span class=s2>&#34;0&#34;</span>           <span class=c1># 0 означает конец итерации</span>
</span></span><span class=line><span class=cl>2<span class=o>)</span> <span class=o>(</span>empty list or <span class=nb>set</span><span class=o>)</span>
</span></span></code></pre></div><p><strong>Пример на Go:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>cursor</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>keys</span> <span class=p>[]</span><span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>batch</span> <span class=p>[]</span><span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>batch</span><span class=p>,</span> <span class=nx>cursor</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Scan</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>cursor</span><span class=p>,</span> <span class=s>&#34;user:*&#34;</span><span class=p>,</span> <span class=mi>100</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>keys</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>keys</span><span class=p>,</span> <span class=nx>batch</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>cursor</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>  <span class=c1>// Конец итерации</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Found keys:&#34;</span><span class=p>,</span> <span class=nx>keys</span><span class=p>)</span>
</span></span></code></pre></div><p><strong>Варианты SCAN:</strong></p><ul><li><code>SCAN</code> — итерация по всем ключам</li><li><code>SSCAN</code> — итерация по элементам множества</li><li><code>HSCAN</code> — итерация по полям хеша</li><li><code>ZSCAN</code> — итерация по элементам отсортированного множества</li></ul><p><strong>Особенности:</strong></p><ul><li><code>COUNT</code> — это подсказка, реальное количество может отличаться</li><li>Один и тот же ключ может быть возвращен несколько раз (но это редко)</li><li>В кластере <code>SCAN</code> сканирует все узлы, что может быть медленнее</li></ul><h3 id=36-очистка-базы-данных>3.6. Очистка базы данных<a hidden class=anchor aria-hidden=true href=#36-очистка-базы-данных>#</a></h3><h4 id=flushdb--flushall>FLUSHDB / FLUSHALL<a hidden class=anchor aria-hidden=true href=#flushdb--flushall>#</a></h4><p><strong>Назначение</strong>: Удаление всех ключей из текущей базы данных (<code>FLUSHDB</code>) или всех баз данных (<code>FLUSHALL</code>).</p><p><strong>⚠️ ВАЖНО: Эти команды ОПАСНЫ в production!</strong></p><p><strong>Синтаксис:</strong></p><pre tabindex=0><code class=language-redis data-lang=redis>FLUSHDB [ASYNC]
FLUSHALL [ASYNC]
</code></pre><p><strong>Примеры через CLI:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>redis-cli&gt; SET key1 <span class=s2>&#34;value1&#34;</span>
</span></span><span class=line><span class=cl>OK
</span></span><span class=line><span class=cl>redis-cli&gt; SET key2 <span class=s2>&#34;value2&#34;</span>
</span></span><span class=line><span class=cl>OK
</span></span><span class=line><span class=cl>redis-cli&gt; FLUSHDB
</span></span><span class=line><span class=cl>OK
</span></span><span class=line><span class=cl>redis-cli&gt; GET key1
</span></span><span class=line><span class=cl><span class=o>(</span>nil<span class=o>)</span>  <span class=c1># Ключ удален</span>
</span></span></code></pre></div><p><strong>Ограничения:</strong></p><ul><li>❌ <strong>Не работает в Redis Cluster</strong>: Эти команды отключены в кластерном режиме</li><li>⚠️ <strong>Удаляет ВСЕ данные</strong>: Невозможно откатить операцию</li><li>⚠️ <strong>Блокирует сервер</strong>: Может занять время на больших базах</li></ul><p><strong>Безопасная альтернатива в кластере:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Использование SCAN + DEL для безопасной очистки</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>safeFlush</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>rdb</span> <span class=o>*</span><span class=nx>redis</span><span class=p>.</span><span class=nx>Client</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>cursor</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>keys</span><span class=p>,</span> <span class=nx>nextCursor</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Scan</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>cursor</span><span class=p>,</span> <span class=s>&#34;*&#34;</span><span class=p>,</span> <span class=mi>1000</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>keys</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>err</span> <span class=p>=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Del</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>keys</span><span class=o>...</span><span class=p>).</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nx>cursor</span> <span class=p>=</span> <span class=nx>nextCursor</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>cursor</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Когда использовать:</strong></p><ul><li>✅ Только в тестовой/разработческой среде</li><li>✅ При полном сбросе данных (с предварительным бэкапом)</li><li>❌ <strong>НИКОГДА</strong> в production без явной необходимости</li></ul><h3 id=37-redis-streams>3.7. Redis Streams<a hidden class=anchor aria-hidden=true href=#37-redis-streams>#</a></h3><p><strong>Streams</strong> — это структура данных для работы с логами событий и сообщениями. Похожа на Kafka, но встроена в Redis.</p><h4 id=xadd--xread--xdel>XADD / XREAD / XDEL<a hidden class=anchor aria-hidden=true href=#xadd--xread--xdel>#</a></h4><p><strong>Назначение</strong>:</p><ul><li><code>XADD</code> — добавление сообщения в поток</li><li><code>XREAD</code> — чтение сообщений из потока</li><li><code>XDEL</code> — удаление сообщения из потока</li></ul><p><strong>Синтаксис:</strong></p><pre tabindex=0><code class=language-redis data-lang=redis>XADD stream * field1 value1 [field2 value2 ...]
XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]
XDEL stream id [id ...]
</code></pre><p><strong>Примеры через CLI:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Добавление сообщения</span>
</span></span><span class=line><span class=cl>redis-cli&gt; XADD events * user_id <span class=m>123</span> action <span class=s2>&#34;login&#34;</span> timestamp <span class=m>1234567890</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;1699123456789-0&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Чтение всех сообщений с начала</span>
</span></span><span class=line><span class=cl>redis-cli&gt; XREAD STREAMS events <span class=m>0</span>
</span></span><span class=line><span class=cl>1<span class=o>)</span> 1<span class=o>)</span> <span class=s2>&#34;events&#34;</span>
</span></span><span class=line><span class=cl>   2<span class=o>)</span> 1<span class=o>)</span> 1<span class=o>)</span> <span class=s2>&#34;1699123456789-0&#34;</span>
</span></span><span class=line><span class=cl>         2<span class=o>)</span> 1<span class=o>)</span> <span class=s2>&#34;user_id&#34;</span>
</span></span><span class=line><span class=cl>            2<span class=o>)</span> <span class=s2>&#34;123&#34;</span>
</span></span><span class=line><span class=cl>            3<span class=o>)</span> <span class=s2>&#34;action&#34;</span>
</span></span><span class=line><span class=cl>            4<span class=o>)</span> <span class=s2>&#34;login&#34;</span>
</span></span><span class=line><span class=cl>            5<span class=o>)</span> <span class=s2>&#34;timestamp&#34;</span>
</span></span><span class=line><span class=cl>            6<span class=o>)</span> <span class=s2>&#34;1234567890&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Чтение новых сообщений (блокирующее)</span>
</span></span><span class=line><span class=cl>redis-cli&gt; XREAD BLOCK <span class=m>1000</span> STREAMS events $
</span></span><span class=line><span class=cl><span class=o>(</span>nil<span class=o>)</span>  <span class=c1># Нет новых сообщений, вернулось через 1 секунду</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Удаление сообщения</span>
</span></span><span class=line><span class=cl>redis-cli&gt; XDEL events 1699123456789-0
</span></span><span class=line><span class=cl><span class=o>(</span>integer<span class=o>)</span> <span class=m>1</span>
</span></span></code></pre></div><p><strong>Пример на Go:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// XADD - добавление события</span>
</span></span><span class=line><span class=cl><span class=nx>id</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>XAdd</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>redis</span><span class=p>.</span><span class=nx>XAddArgs</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Stream</span><span class=p>:</span> <span class=s>&#34;events&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>Values</span><span class=p>:</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}{</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;user_id&#34;</span><span class=p>:</span>   <span class=mi>123</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;action&#34;</span><span class=p>:</span>    <span class=s>&#34;login&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;timestamp&#34;</span><span class=p>:</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Unix</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>}).</span><span class=nf>Result</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Event ID:&#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// XREAD - чтение событий</span>
</span></span><span class=line><span class=cl><span class=nx>streams</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>XRead</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>redis</span><span class=p>.</span><span class=nx>XReadArgs</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Streams</span><span class=p>:</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;events&#34;</span><span class=p>,</span> <span class=s>&#34;0&#34;</span><span class=p>},</span>  <span class=c1>// 0 = с начала</span>
</span></span><span class=line><span class=cl>    <span class=nx>Count</span><span class=p>:</span>   <span class=mi>10</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>Block</span><span class=p>:</span>   <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}).</span><span class=nf>Result</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>stream</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>streams</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>message</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>stream</span><span class=p>.</span><span class=nx>Messages</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;ID: %s, Values: %v\n&#34;</span><span class=p>,</span> <span class=nx>message</span><span class=p>.</span><span class=nx>ID</span><span class=p>,</span> <span class=nx>message</span><span class=p>.</span><span class=nx>Values</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// XDEL - удаление события</span>
</span></span><span class=line><span class=cl><span class=nx>err</span> <span class=p>=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>XDel</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;events&#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>).</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>panic</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Особенности Streams:</strong></p><ul><li>Сообщения упорядочены по времени (ID содержит timestamp)</li><li>Поддержка consumer groups для распределенной обработки</li><li>Автоматическое удаление старых сообщений (MAXLEN)</li><li>В кластере stream должен быть на одном узле (используйте hash tags)</li></ul><p><strong>Использование в кластере:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Важно: stream ключ должен быть обернут в hash tag</span>
</span></span><span class=line><span class=cl><span class=nx>streamKey</span> <span class=o>:=</span> <span class=s>&#34;{events}:myStream&#34;</span>  <span class=c1>// Все операции с этим stream на одном узле</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>id</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>XAdd</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>redis</span><span class=p>.</span><span class=nx>XAddArgs</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Stream</span><span class=p>:</span> <span class=nx>streamKey</span><span class=p>,</span>  <span class=c1>// Используем обернутый ключ</span>
</span></span><span class=line><span class=cl>    <span class=nx>Values</span><span class=p>:</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}{</span><span class=s>&#34;data&#34;</span><span class=p>:</span> <span class=s>&#34;value&#34;</span><span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>}).</span><span class=nf>Result</span><span class=p>()</span>
</span></span></code></pre></div><p><strong>Типичные сценарии использования:</strong></p><ul><li>Event sourcing (хранение истории событий)</li><li>Очереди сообщений</li><li>Логирование и аудит</li><li>Real-time аналитика</li></ul><h3 id=38-дополнительные-полезные-команды>3.8. Дополнительные полезные команды<a hidden class=anchor aria-hidden=true href=#38-дополнительные-полезные-команды>#</a></h3><h4 id=incr--decr>INCR / DECR<a hidden class=anchor aria-hidden=true href=#incr--decr>#</a></h4><p>Атомарное увеличение/уменьшение числового значения.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Счетчик просмотров</span>
</span></span><span class=line><span class=cl><span class=nx>views</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Incr</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;page:123:views&#34;</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>// Атомарное увеличение на N</span>
</span></span><span class=line><span class=cl><span class=nx>views</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>IncrBy</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;page:123:views&#34;</span><span class=p>,</span> <span class=mi>5</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span></code></pre></div><h4 id=hset--hget--hgetall>HSET / HGET / HGETALL<a hidden class=anchor aria-hidden=true href=#hset--hget--hgetall>#</a></h4><p>Работа с хешами (hash maps).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Сохранение объекта пользователя</span>
</span></span><span class=line><span class=cl><span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>HSet</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;user:1&#34;</span><span class=p>,</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}{</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;name&#34;</span><span class=p>:</span>  <span class=s>&#34;Иван&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;email&#34;</span><span class=p>:</span> <span class=s>&#34;ivan@example.com&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;age&#34;</span><span class=p>:</span>   <span class=mi>25</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}).</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Получение всех полей</span>
</span></span><span class=line><span class=cl><span class=nx>user</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>HGetAll</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;user:1&#34;</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>// map[string]string{&#34;name&#34;: &#34;Иван&#34;, &#34;email&#34;: &#34;ivan@example.com&#34;, &#34;age&#34;: &#34;25&#34;}</span>
</span></span></code></pre></div><h4 id=lpush--rpush--lpop--rpop>LPUSH / RPUSH / LPOP / RPOP<a hidden class=anchor aria-hidden=true href=#lpush--rpush--lpop--rpop>#</a></h4><p>Работа со списками (очереди, стеки).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Добавление в очередь</span>
</span></span><span class=line><span class=cl><span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>LPush</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;queue:tasks&#34;</span><span class=p>,</span> <span class=s>&#34;task1&#34;</span><span class=p>,</span> <span class=s>&#34;task2&#34;</span><span class=p>).</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Извлечение из очереди</span>
</span></span><span class=line><span class=cl><span class=nx>task</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>RPop</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;queue:tasks&#34;</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span></code></pre></div><h4 id=zadd--zrange>ZADD / ZRANGE<a hidden class=anchor aria-hidden=true href=#zadd--zrange>#</a></h4><p>Работа с отсортированными множествами (sorted sets).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Добавление в рейтинг</span>
</span></span><span class=line><span class=cl><span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>ZAdd</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;leaderboard&#34;</span><span class=p>,</span> <span class=nx>redis</span><span class=p>.</span><span class=nx>Z</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Score</span><span class=p>:</span>  <span class=mi>1000</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>Member</span><span class=p>:</span> <span class=s>&#34;player1&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}).</span><span class=nf>Err</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Получение топ-10</span>
</span></span><span class=line><span class=cl><span class=nx>topPlayers</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>ZRevRange</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;leaderboard&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>9</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span></code></pre></div><hr><h2 id=6-практические-рекомендации>6. Практические рекомендации<a hidden class=anchor aria-hidden=true href=#6-практические-рекомендации>#</a></h2><h3 id=41-безопасное-использование-redis-в-production>4.1. Безопасное использование Redis в production<a hidden class=anchor aria-hidden=true href=#41-безопасное-использование-redis-в-production>#</a></h3><h4 id=аутентификация>Аутентификация<a hidden class=anchor aria-hidden=true href=#аутентификация>#</a></h4><p>Всегда используйте пароль для защиты Redis:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># redis.conf</span>
</span></span><span class=line><span class=cl>requirepass your_strong_password_here
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>rdb</span> <span class=o>:=</span> <span class=nx>redis</span><span class=p>.</span><span class=nf>NewClient</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>redis</span><span class=p>.</span><span class=nx>Options</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Addr</span><span class=p>:</span>     <span class=s>&#34;localhost:6379&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>Password</span><span class=p>:</span> <span class=s>&#34;your_strong_password_here&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><h4 id=защита-от-flushdb>Защита от FLUSHDB<a hidden class=anchor aria-hidden=true href=#защита-от-flushdb>#</a></h4><ol><li><strong>Переименуйте опасные команды:</strong></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># redis.conf</span>
</span></span><span class=line><span class=cl>rename-command FLUSHDB <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>rename-command FLUSHALL <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>rename-command CONFIG <span class=s2>&#34;CONFIG_9a7b8c5d4e3f2g1h0i9j8k7l6m5n4o3p2q1r0&#34;</span>
</span></span></code></pre></div><ol start=2><li><strong>Используйте отдельные инстансы для разных целей:</strong><ul><li>Production данные</li><li>Кэш</li><li>Очереди</li></ul></li></ol><h4 id=ограничение-доступа>Ограничение доступа<a hidden class=anchor aria-hidden=true href=#ограничение-доступа>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># redis.conf</span>
</span></span><span class=line><span class=cl><span class=c1># Разрешить подключения только с определенных IP</span>
</span></span><span class=line><span class=cl><span class=nb>bind</span> 127.0.0.1 10.0.0.0/8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Ограничить количество подключений</span>
</span></span><span class=line><span class=cl>maxclients <span class=m>10000</span>
</span></span></code></pre></div><h3 id=42-когда-использовать-кластер-а-когда-standalone>4.2. Когда использовать кластер, а когда standalone<a hidden class=anchor aria-hidden=true href=#42-когда-использовать-кластер-а-когда-standalone>#</a></h3><p><strong>Используйте Standalone, если:</strong></p><ul><li>✅ Объем данных &lt; 50-100 GB</li><li>✅ Нет критических требований к uptime</li><li>✅ Простота важнее масштабируемости</li><li>✅ Разработка и тестирование</li></ul><p><strong>Используйте Cluster, если:</strong></p><ul><li>✅ Объем данных > 100 GB</li><li>✅ Требуется 99.9%+ uptime</li><li>✅ Нужно горизонтальное масштабирование</li><li>✅ Высокая нагрузка (миллионы операций в секунду)</li></ul><h3 id=43-ошибки-новичков>4.3. Ошибки новичков<a hidden class=anchor aria-hidden=true href=#43-ошибки-новичков>#</a></h3><h4 id=-использование-keys--в-production>❌ Использование KEYS * в production<a hidden class=anchor aria-hidden=true href=#-использование-keys--в-production>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ПЛОХО - блокирует сервер</span>
</span></span><span class=line><span class=cl><span class=nx>keys</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Keys</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;*&#34;</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ХОРОШО - используйте SCAN</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>cursor</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>batch</span><span class=p>,</span> <span class=nx>nextCursor</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Scan</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>cursor</span><span class=p>,</span> <span class=s>&#34;*&#34;</span><span class=p>,</span> <span class=mi>100</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// обработка batch</span>
</span></span><span class=line><span class=cl>    <span class=nx>cursor</span> <span class=p>=</span> <span class=nx>nextCursor</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>cursor</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=-игнорирование-ttl>❌ Игнорирование TTL<a hidden class=anchor aria-hidden=true href=#-игнорирование-ttl>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ПЛОХО - данные накапливаются</span>
</span></span><span class=line><span class=cl><span class=nx>rdb</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;cache:key&#34;</span><span class=p>,</span> <span class=s>&#34;value&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ХОРОШО - устанавливайте TTL</span>
</span></span><span class=line><span class=cl><span class=nx>rdb</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;cache:key&#34;</span><span class=p>,</span> <span class=s>&#34;value&#34;</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Hour</span><span class=p>)</span>
</span></span></code></pre></div><h4 id=-использование-транзакций-с-ключами-на-разных-узлах>❌ Использование транзакций с ключами на разных узлах<a hidden class=anchor aria-hidden=true href=#-использование-транзакций-с-ключами-на-разных-узлах>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ПЛОХО - в кластере не сработает</span>
</span></span><span class=line><span class=cl><span class=nx>pipe</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>TxPipeline</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>pipe</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;user:1&#34;</span><span class=p>,</span> <span class=s>&#34;value1&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>  <span class=c1>// Узел A</span>
</span></span><span class=line><span class=cl><span class=nx>pipe</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;user:2&#34;</span><span class=p>,</span> <span class=s>&#34;value2&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>  <span class=c1>// Узел B</span>
</span></span><span class=line><span class=cl><span class=nx>pipe</span><span class=p>.</span><span class=nf>Exec</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>  <span class=c1>// ОШИБКА: CROSSSLOT</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ХОРОШО - используйте hash tags</span>
</span></span><span class=line><span class=cl><span class=nx>pipe</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>TxPipeline</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>pipe</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;{user}:1&#34;</span><span class=p>,</span> <span class=s>&#34;value1&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>  <span class=c1>// Оба на одном узле</span>
</span></span><span class=line><span class=cl><span class=nx>pipe</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;{user}:2&#34;</span><span class=p>,</span> <span class=s>&#34;value2&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>  <span class=c1>// благодаря hash tag</span>
</span></span><span class=line><span class=cl><span class=nx>pipe</span><span class=p>.</span><span class=nf>Exec</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>  <span class=c1>// OK</span>
</span></span></code></pre></div><h4 id=-неправильная-обработка-ошибок>❌ Неправильная обработка ошибок<a hidden class=anchor aria-hidden=true href=#-неправильная-обработка-ошибок>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ПЛОХО</span>
</span></span><span class=line><span class=cl><span class=nx>val</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;key&#34;</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>val</span><span class=p>)</span>  <span class=c1>// Может быть пустая строка, если ключ не существует</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ХОРОШО</span>
</span></span><span class=line><span class=cl><span class=nx>val</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Get</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=s>&#34;key&#34;</span><span class=p>).</span><span class=nf>Result</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>redis</span><span class=p>.</span><span class=nx>Nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Ключ не существует</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Другая ошибка</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// Ключ существует</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>val</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=44-оптимизация-производительности>4.4. Оптимизация производительности<a hidden class=anchor aria-hidden=true href=#44-оптимизация-производительности>#</a></h3><ol><li><strong>Используйте Pipeline для множественных операций:</strong></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>pipe</span> <span class=o>:=</span> <span class=nx>rdb</span><span class=p>.</span><span class=nf>Pipeline</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>1000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>pipe</span><span class=p>.</span><span class=nf>Set</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;key:%d&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>),</span> <span class=s>&#34;value&#34;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>pipe</span><span class=p>.</span><span class=nf>Exec</span><span class=p>(</span><span class=nx>ctx</span><span class=p>)</span>  <span class=c1>// Одна сетевая операция вместо 1000</span>
</span></span></code></pre></div><ol start=2><li><strong>Настройте connection pooling:</strong></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>rdb</span> <span class=o>:=</span> <span class=nx>redis</span><span class=p>.</span><span class=nf>NewClient</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>redis</span><span class=p>.</span><span class=nx>Options</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Addr</span><span class=p>:</span>         <span class=s>&#34;localhost:6379&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>PoolSize</span><span class=p>:</span>     <span class=mi>20</span><span class=p>,</span>  <span class=c1>// Количество соединений в пуле</span>
</span></span><span class=line><span class=cl>    <span class=nx>MinIdleConns</span><span class=p>:</span> <span class=mi>10</span><span class=p>,</span>  <span class=c1>// Минимальное количество idle соединений</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><ol start=3><li><strong>Используйте подходящие структуры данных:</strong><ul><li>Строки для простых значений</li><li>Хеши для объектов</li><li>Списки для очередей</li><li>Sets для уникальных коллекций</li><li>Sorted Sets для рейтингов</li></ul></li></ol><hr><h2 id=7-источники-и-дальнейшее-изучение>7. Источники и дальнейшее изучение<a hidden class=anchor aria-hidden=true href=#7-источники-и-дальнейшее-изучение>#</a></h2><h3 id=официальная-документация>Официальная документация<a hidden class=anchor aria-hidden=true href=#официальная-документация>#</a></h3><ul><li><p><strong>Redis Documentation</strong>: <a href=https://redis.io/documentation>https://redis.io/documentation</a></p><ul><li>Полная документация по всем командам и возможностям</li><li>Руководства по настройке и оптимизации</li><li>Примеры использования</li></ul></li><li><p><strong>Redis Commands Reference</strong>: <a href=https://redis.io/commands>https://redis.io/commands</a></p><ul><li>Справочник по всем командам Redis</li><li>Описание параметров и возвращаемых значений</li><li>Примеры использования</li></ul></li></ul><h3 id=книги>Книги<a hidden class=anchor aria-hidden=true href=#книги>#</a></h3><ul><li><p><strong>Redis in Action</strong> by Josiah L. Carlson</p><ul><li>Практическое руководство по использованию Redis</li><li>Реальные примеры и паттерны</li><li>Оптимизация и best practices</li></ul></li><li><p><strong>Redis: The Definitive Guide</strong> by Josiah L. Carlson, Carlos Baquero, and others</p><ul><li>Подробное описание архитектуры Redis</li><li>Глубокое погружение в типы данных</li><li>Администрирование и мониторинг</li></ul></li></ul><h3 id=онлайн-ресурсы>Онлайн-ресурсы<a hidden class=anchor aria-hidden=true href=#онлайн-ресурсы>#</a></h3><ul><li><p><strong>Redis University</strong>: <a href=https://university.redis.com/>https://university.redis.com/</a></p><ul><li>Бесплатные курсы по Redis</li><li>Видео-лекции и практические задания</li><li>Сертификация</li></ul></li><li><p><strong>Redis Playground</strong>: <a href=https://redis.io/docs/ui/play/>https://redis.io/docs/ui/play/</a></p><ul><li>Интерактивная песочница для экспериментов</li><li>Примеры команд и сценариев</li><li>Без необходимости установки Redis локально</li></ul></li></ul><h3 id=github-и-сообщество>GitHub и сообщество<a hidden class=anchor aria-hidden=true href=#github-и-сообщество>#</a></h3><ul><li><p><strong>Redis GitHub</strong>: <a href=https://github.com/redis/redis>https://github.com/redis/redis</a></p><ul><li>Исходный код Redis</li><li>Issue tracker и обсуждения</li><li>Документация разработчика</li></ul></li><li><p><strong>Redis Community</strong>: <a href=https://redis.io/community>https://redis.io/community</a></p><ul><li>Форум сообщества</li><li>Discord канал</li><li>Meetups и конференции</li></ul></li></ul><h3 id=дополнительные-материалы>Дополнительные материалы<a hidden class=anchor aria-hidden=true href=#дополнительные-материалы>#</a></h3><ul><li><p><strong>Redis Labs Blog</strong>: <a href=https://redis.com/blog/>https://redis.com/blog/</a></p><ul><li>Статьи о best practices</li><li>Кейсы использования</li><li>Новости и обновления</li></ul></li><li><p><strong>Redis YouTube Channel</strong>: <a href=https://www.youtube.com/c/RedisLabs>https://www.youtube.com/c/RedisLabs</a></p><ul><li>Видео-туториалы</li><li>Вебинары и презентации</li><li>Демонстрации возможностей</li></ul></li></ul><hr><h2 id=заключение>Заключение<a hidden class=anchor aria-hidden=true href=#заключение>#</a></h2><p>Redis — это мощный инструмент для работы с данными в памяти, который может значительно ускорить ваше приложение при правильном использовании. Понимание различий между режимами работы, знание основных команд и следование best practices помогут вам эффективно использовать Redis в ваших проектах.</p><p>Помните:</p><ul><li>Выбирайте режим работы в зависимости от ваших требований</li><li>Используйте подходящие структуры данных для ваших задач</li><li>Всегда устанавливайте TTL для временных данных</li><li>Избегайте блокирующих команд в production</li><li>Используйте hash tags в кластере для группировки связанных данных</li></ul><p>Удачи в изучении Redis! 🚀</p><hr><p><em>Документ подготовлен на основе официальной документации Redis 7.x и практического опыта разработки.</em></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://akozadaev.github.io/myblog/>Персональный блог бэкенд-разработчика</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>